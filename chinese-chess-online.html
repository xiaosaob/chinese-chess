<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>中国象棋 - 在线对战</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Microsoft YaHei', 'SimHei', sans-serif;
        }
        .game-container {
            text-align: center;
            padding: 20px;
        }
        h1 {
            color: #f4d03f;
            margin-bottom: 10px;
            font-size: 32px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .status {
            color: #fff;
            font-size: 20px;
            margin-bottom: 10px;
            min-height: 30px;
        }
        .player-info {
            color: #4ecca3;
            font-size: 16px;
            margin-bottom: 10px;
        }
        .board-container {
            display: inline-block;
            padding: 20px;
            background: #d4a056;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        canvas {
            cursor: pointer;
        }
        .controls {
            margin-top: 20px;
        }
        button {
            padding: 12px 30px;
            font-size: 18px;
            background: #c0392b;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px 10px;
            font-family: inherit;
            transition: background 0.3s;
        }
        button:hover {
            background: #e74c3c;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .lobby {
            background: rgba(0,0,0,0.8);
            padding: 40px;
            border-radius: 15px;
            max-width: 500px;
        }
        .lobby h2 {
            color: #f4d03f;
            margin-bottom: 20px;
        }
        .lobby p {
            color: #fff;
            margin-bottom: 15px;
        }
        .lobby input {
            padding: 12px 20px;
            font-size: 18px;
            border: none;
            border-radius: 5px;
            width: 100%;
            margin-bottom: 15px;
            text-align: center;
        }
        .share-link {
            background: #2c3e50;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            word-break: break-all;
        }
        .share-link a {
            color: #3498db;
            text-decoration: none;
        }
        .waiting {
            color: #f4d03f;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 14px;
        }
        .connected {
            background: #27ae60;
            color: white;
        }
        .disconnected {
            background: #c0392b;
            color: white;
        }
        .game-area {
            display: none;
        }
        .copy-btn {
            padding: 8px 20px;
            font-size: 14px;
            background: #3498db;
            margin-top: 10px;
        }
        .copy-btn:hover {
            background: #2980b9;
        }
    </style>
</head>
<body>
    <div class="connection-status disconnected" id="connectionStatus">未连接</div>

    <div class="game-container">
        <!-- Lobby -->
        <div class="lobby" id="lobby">
            <h2>中国象棋 - 在线对战</h2>
            <p>与朋友一起下棋!</p>

            <div id="createSection">
                <button onclick="createGame()">创建新游戏</button>
                <p style="margin: 20px 0; color: #888;">- 或者 -</p>
                <input type="text" id="joinRoomId" placeholder="输入房间号加入游戏">
                <button onclick="joinGame()">加入游戏</button>
            </div>

            <div id="waitingSection" style="display: none;">
                <p class="waiting">等待对手加入...</p>
                <div class="share-link">
                    <p style="color: #888; font-size: 14px;">分享此链接给朋友:</p>
                    <a id="shareLink" href="#" target="_blank"></a>
                </div>
                <button class="copy-btn" onclick="copyLink()">复制链接</button>
                <p style="margin-top: 15px; color: #888; font-size: 14px;">房间号: <span id="roomIdDisplay"></span></p>
            </div>
        </div>

        <!-- Game Area -->
        <div class="game-area" id="gameArea">
            <h1>中国象棋</h1>
            <div class="player-info" id="playerInfo">你是: 红方</div>
            <div class="status" id="status">红方先行</div>
            <div class="board-container">
                <canvas id="board" width="520" height="580"></canvas>
            </div>
            <div class="controls">
                <button onclick="requestRematch()" id="rematchBtn" style="display:none;">再来一局</button>
                <button onclick="leaveGame()">离开游戏</button>
                <button id="soundBtn" onclick="toggleSound()">关闭音效</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

    <script>
        // ============================================
        // FIREBASE CONFIGURATION - REPLACE WITH YOUR OWN
        // ============================================

        // Your web app's Firebase configuration
        // For Firebase JS SDK v7.20.0 and later, measurementId is optional
        const firebaseConfig = {
            apiKey: "AIzaSyDsV1zjfCwYXoq6Ua3AZ4QVbLt1Sdgyd0Y",
            authDomain: "chinese-chess-9a981.firebaseapp.com",
            databaseURL: "https://chinese-chess-9a981-default-rtdb.firebaseio.com",
            projectId: "chinese-chess-9a981",
            storageBucket: "chinese-chess-9a981.firebasestorage.app",
            messagingSenderId: "1085517521136",
            appId: "1:1085517521136:web:636b9648a132ce740da235",
            measurementId: "G-Z9Y2LS56EL"
        };

        // Initialize Firebase
        let db = null;
        let gameRef = null;
        let roomId = null;
        let myColor = null;
        let gameStarted = false;

        try {
            firebase.initializeApp(firebaseConfig);
            db = firebase.database();
            document.getElementById('connectionStatus').className = 'connection-status connected';
            document.getElementById('connectionStatus').textContent = '已连接';
        } catch (e) {
            console.error('Firebase initialization failed:', e);
            alert('Firebase 配置错误，请检查配置信息');
        }

        // Check URL for room ID
        window.onload = function() {
            const urlParams = new URLSearchParams(window.location.search);
            const urlRoomId = urlParams.get('room');
            if (urlRoomId) {
                document.getElementById('joinRoomId').value = urlRoomId;
                joinGame();
            }
        };

        function generateRoomId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function createGame() {
            roomId = generateRoomId();
            myColor = 'red';

            gameRef = db.ref('games/' + roomId);

            const initialState = {
                board: getInitialBoard(),
                currentPlayer: 'red',
                redPlayer: true,
                blackPlayer: false,
                lastMove: null,
                gameOver: false,
                winner: null,
                rematchRequest: null,
                created: Date.now()
            };

            gameRef.set(initialState).then(() => {
                document.getElementById('createSection').style.display = 'none';
                document.getElementById('waitingSection').style.display = 'block';

                const shareUrl = window.location.origin + window.location.pathname + '?room=' + roomId;
                document.getElementById('shareLink').href = shareUrl;
                document.getElementById('shareLink').textContent = shareUrl;
                document.getElementById('roomIdDisplay').textContent = roomId;

                // Listen for opponent joining
                gameRef.child('blackPlayer').on('value', (snapshot) => {
                    if (snapshot.val() === true) {
                        startGame();
                    }
                });
            });
        }

        function joinGame() {
            roomId = document.getElementById('joinRoomId').value.trim().toUpperCase();
            if (!roomId) {
                alert('请输入房间号');
                return;
            }

            gameRef = db.ref('games/' + roomId);

            gameRef.once('value').then((snapshot) => {
                const game = snapshot.val();
                if (!game) {
                    alert('房间不存在');
                    return;
                }
                if (game.blackPlayer) {
                    alert('房间已满');
                    return;
                }

                myColor = 'black';
                gameRef.update({ blackPlayer: true }).then(() => {
                    startGame();
                });
            });
        }

        function startGame() {
            gameStarted = true;
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('gameArea').style.display = 'block';
            document.getElementById('playerInfo').textContent = '你是: ' + (myColor === 'red' ? '红方' : '黑方');

            initBoard();
            setupGameListeners();
            drawBoard();
        }

        function setupGameListeners() {
            gameRef.on('value', (snapshot) => {
                const game = snapshot.val();
                if (!game) {
                    alert('游戏已结束');
                    leaveGame();
                    return;
                }

                // Update board state
                board = game.board;
                currentPlayer = game.currentPlayer;
                lastMove = game.lastMove;
                gameOver = game.gameOver;

                if (game.lastMove && game.lastMoveBy !== myColor) {
                    // Opponent made a move - play sound
                    if (game.lastMoveWasCapture) {
                        playSound('capture');
                    } else {
                        playSound('move');
                    }
                    if (game.inCheck && currentPlayer === myColor) {
                        playSound('check');
                    }
                }

                // Update status
                if (gameOver) {
                    document.getElementById('rematchBtn').style.display = 'inline-block';
                    if (game.winner === myColor) {
                        statusEl.textContent = '你赢了!';
                        playSound('victory');
                    } else {
                        statusEl.textContent = '你输了!';
                        playSound('defeat');
                    }
                } else if (currentPlayer === myColor) {
                    statusEl.textContent = '轮到你走棋';
                } else {
                    statusEl.textContent = '等待对手...';
                }

                // Handle rematch request
                if (game.rematchRequest && game.rematchRequest !== myColor) {
                    if (confirm('对手请求再来一局，是否同意？')) {
                        gameRef.update({
                            board: getInitialBoard(),
                            currentPlayer: 'red',
                            lastMove: null,
                            gameOver: false,
                            winner: null,
                            rematchRequest: null,
                            inCheck: false
                        });
                        document.getElementById('rematchBtn').style.display = 'none';
                    }
                }

                drawBoard();
            });

            // Handle disconnection
            gameRef.child(myColor === 'red' ? 'redPlayer' : 'blackPlayer').onDisconnect().set(false);
        }

        function leaveGame() {
            if (gameRef) {
                gameRef.off();
                if (myColor === 'red') {
                    gameRef.remove();
                } else {
                    gameRef.update({ blackPlayer: false });
                }
            }
            window.location.href = window.location.pathname;
        }

        function requestRematch() {
            gameRef.update({ rematchRequest: myColor });
            alert('已发送再来一局请求，等待对手确认...');
        }

        function copyLink() {
            const link = document.getElementById('shareLink').href;
            navigator.clipboard.writeText(link).then(() => {
                alert('链接已复制!');
            });
        }

        // ============================================
        // GAME LOGIC (adapted from single player version)
        // ============================================

        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');

        // Sound system
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let soundEnabled = true;

        function playSound(type) {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            switch (type) {
                case 'select':
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.1);
                    break;
                case 'move':
                    oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.1);
                    oscillator.type = 'triangle';
                    gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.15);
                    break;
                case 'capture':
                    oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.2);
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.25);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.25);
                    break;
                case 'check':
                    oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime + 0.1);
                    oscillator.frequency.setValueAtTime(600, audioCtx.currentTime + 0.2);
                    oscillator.type = 'square';
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.35);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.35);
                    break;
                case 'victory':
                    [523, 659, 784, 1047].forEach((freq, i) => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        osc.frequency.setValueAtTime(freq, audioCtx.currentTime + i * 0.15);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0.3, audioCtx.currentTime + i * 0.15);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.15 + 0.3);
                        osc.start(audioCtx.currentTime + i * 0.15);
                        osc.stop(audioCtx.currentTime + i * 0.15 + 0.3);
                    });
                    return;
                case 'defeat':
                    oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.5);
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.6);
                    break;
            }
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundBtn').textContent = soundEnabled ? '关闭音效' : '开启音效';
        }

        const CELL_SIZE = 57;
        const MARGIN = 30;
        const COLS = 9;
        const ROWS = 10;

        const EMPTY = 0;
        const R_GENERAL = 1, R_ADVISOR = 2, R_ELEPHANT = 3, R_HORSE = 4, R_CHARIOT = 5, R_CANNON = 6, R_SOLDIER = 7;
        const B_GENERAL = 11, B_ADVISOR = 12, B_ELEPHANT = 13, B_HORSE = 14, B_CHARIOT = 15, B_CANNON = 16, B_SOLDIER = 17;

        const pieceNames = {
            [R_GENERAL]: '帅', [R_ADVISOR]: '仕', [R_ELEPHANT]: '相', [R_HORSE]: '馬',
            [R_CHARIOT]: '車', [R_CANNON]: '炮', [R_SOLDIER]: '兵',
            [B_GENERAL]: '将', [B_ADVISOR]: '士', [B_ELEPHANT]: '象', [B_HORSE]: '马',
            [B_CHARIOT]: '车', [B_CANNON]: '砲', [B_SOLDIER]: '卒'
        };

        let board = [];
        let selectedPiece = null;
        let validMoves = [];
        let currentPlayer = 'red';
        let gameOver = false;
        let lastMove = null;

        function isRed(piece) { return piece >= 1 && piece <= 7; }
        function isBlack(piece) { return piece >= 11 && piece <= 17; }
        function isEnemy(piece1, piece2) {
            return (isRed(piece1) && isBlack(piece2)) || (isBlack(piece1) && isRed(piece2));
        }
        function isMyPiece(piece) {
            return myColor === 'red' ? isRed(piece) : isBlack(piece);
        }

        function getInitialBoard() {
            const b = Array(ROWS).fill(null).map(() => Array(COLS).fill(EMPTY));
            b[0][0] = B_CHARIOT; b[0][8] = B_CHARIOT;
            b[0][1] = B_HORSE; b[0][7] = B_HORSE;
            b[0][2] = B_ELEPHANT; b[0][6] = B_ELEPHANT;
            b[0][3] = B_ADVISOR; b[0][5] = B_ADVISOR;
            b[0][4] = B_GENERAL;
            b[2][1] = B_CANNON; b[2][7] = B_CANNON;
            b[3][0] = B_SOLDIER; b[3][2] = B_SOLDIER; b[3][4] = B_SOLDIER;
            b[3][6] = B_SOLDIER; b[3][8] = B_SOLDIER;
            b[9][0] = R_CHARIOT; b[9][8] = R_CHARIOT;
            b[9][1] = R_HORSE; b[9][7] = R_HORSE;
            b[9][2] = R_ELEPHANT; b[9][6] = R_ELEPHANT;
            b[9][3] = R_ADVISOR; b[9][5] = R_ADVISOR;
            b[9][4] = R_GENERAL;
            b[7][1] = R_CANNON; b[7][7] = R_CANNON;
            b[6][0] = R_SOLDIER; b[6][2] = R_SOLDIER; b[6][4] = R_SOLDIER;
            b[6][6] = R_SOLDIER; b[6][8] = R_SOLDIER;
            return b;
        }

        function initBoard() {
            board = getInitialBoard();
        }

        function drawBoard() {
            ctx.fillStyle = '#e8c373';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#5d4037';
            ctx.lineWidth = 1;

            for (let i = 0; i < ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(MARGIN, MARGIN + i * CELL_SIZE);
                ctx.lineTo(MARGIN + 8 * CELL_SIZE, MARGIN + i * CELL_SIZE);
                ctx.stroke();
            }

            for (let j = 0; j < COLS; j++) {
                ctx.beginPath();
                ctx.moveTo(MARGIN + j * CELL_SIZE, MARGIN);
                ctx.lineTo(MARGIN + j * CELL_SIZE, MARGIN + 4 * CELL_SIZE);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(MARGIN + j * CELL_SIZE, MARGIN + 5 * CELL_SIZE);
                ctx.lineTo(MARGIN + j * CELL_SIZE, MARGIN + 9 * CELL_SIZE);
                ctx.stroke();
            }

            ctx.beginPath();
            ctx.moveTo(MARGIN, MARGIN + 4 * CELL_SIZE);
            ctx.lineTo(MARGIN, MARGIN + 5 * CELL_SIZE);
            ctx.moveTo(MARGIN + 8 * CELL_SIZE, MARGIN + 4 * CELL_SIZE);
            ctx.lineTo(MARGIN + 8 * CELL_SIZE, MARGIN + 5 * CELL_SIZE);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(MARGIN + 3 * CELL_SIZE, MARGIN);
            ctx.lineTo(MARGIN + 5 * CELL_SIZE, MARGIN + 2 * CELL_SIZE);
            ctx.moveTo(MARGIN + 5 * CELL_SIZE, MARGIN);
            ctx.lineTo(MARGIN + 3 * CELL_SIZE, MARGIN + 2 * CELL_SIZE);
            ctx.moveTo(MARGIN + 3 * CELL_SIZE, MARGIN + 7 * CELL_SIZE);
            ctx.lineTo(MARGIN + 5 * CELL_SIZE, MARGIN + 9 * CELL_SIZE);
            ctx.moveTo(MARGIN + 5 * CELL_SIZE, MARGIN + 7 * CELL_SIZE);
            ctx.lineTo(MARGIN + 3 * CELL_SIZE, MARGIN + 9 * CELL_SIZE);
            ctx.stroke();

            ctx.font = '24px serif';
            ctx.fillStyle = '#5d4037';
            ctx.textAlign = 'center';
            ctx.fillText('楚 河', MARGIN + 1.5 * CELL_SIZE, MARGIN + 4.6 * CELL_SIZE);
            ctx.fillText('汉 界', MARGIN + 6.5 * CELL_SIZE, MARGIN + 4.6 * CELL_SIZE);

            // Draw last move highlight
            if (lastMove) {
                const fromX = MARGIN + lastMove.fromCol * CELL_SIZE;
                const fromY = MARGIN + lastMove.fromRow * CELL_SIZE;
                ctx.fillStyle = 'rgba(255, 215, 0, 0.4)';
                ctx.fillRect(fromX - 28, fromY - 28, 56, 56);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.strokeRect(fromX - 28, fromY - 28, 56, 56);

                const toX = MARGIN + lastMove.toCol * CELL_SIZE;
                const toY = MARGIN + lastMove.toRow * CELL_SIZE;
                ctx.fillStyle = 'rgba(255, 140, 0, 0.4)';
                ctx.fillRect(toX - 28, toY - 28, 56, 56);
                ctx.strokeStyle = '#ff8c00';
                ctx.lineWidth = 2;
                ctx.strokeRect(toX - 28, toY - 28, 56, 56);
            }

            validMoves.forEach(move => {
                const x = MARGIN + move.col * CELL_SIZE;
                const y = MARGIN + move.row * CELL_SIZE;
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.fillStyle = board[move.row][move.col] !== EMPTY ? 'rgba(255,0,0,0.5)' : 'rgba(0,128,0,0.5)';
                ctx.fill();
            });

            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const piece = board[row][col];
                    if (piece !== EMPTY) {
                        drawPiece(col, row, piece, selectedPiece && selectedPiece.row === row && selectedPiece.col === col);
                    }
                }
            }
        }

        function drawPiece(col, row, piece, selected) {
            const x = MARGIN + col * CELL_SIZE;
            const y = MARGIN + row * CELL_SIZE;
            const radius = 25;

            ctx.beginPath();
            ctx.arc(x + 2, y + 2, radius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fill();

            const gradient = ctx.createRadialGradient(x - 5, y - 5, 0, x, y, radius);
            gradient.addColorStop(0, '#fff8dc');
            gradient.addColorStop(1, '#deb887');
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            ctx.strokeStyle = selected ? '#00ff00' : '#8b4513';
            ctx.lineWidth = selected ? 3 : 2;
            ctx.stroke();

            ctx.font = 'bold 28px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = isRed(piece) ? '#c41e3a' : '#1a1a1a';
            ctx.fillText(pieceNames[piece], x, y + 2);
        }

        function getValidMoves(row, col, boardState = board) {
            const piece = boardState[row][col];
            const moves = [];

            const addMove = (r, c) => {
                if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                    const target = boardState[r][c];
                    if (target === EMPTY || isEnemy(piece, target)) {
                        moves.push({ row: r, col: c });
                    }
                }
            };

            const canMoveTo = (r, c) => {
                if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return false;
                const target = boardState[r][c];
                return target === EMPTY || isEnemy(piece, target);
            };

            const pieceType = piece <= 7 ? piece : piece - 10;
            const isRedPiece = isRed(piece);

            switch (pieceType) {
                case 1:
                    const gMinRow = isRedPiece ? 7 : 0;
                    const gMaxRow = isRedPiece ? 9 : 2;
                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                        const nr = row + dr, nc = col + dc;
                        if (nr >= gMinRow && nr <= gMaxRow && nc >= 3 && nc <= 5 && canMoveTo(nr, nc)) {
                            moves.push({ row: nr, col: nc });
                        }
                    });
                    const enemyGeneral = isRedPiece ? B_GENERAL : R_GENERAL;
                    let blocked = false;
                    const dir = isRedPiece ? -1 : 1;
                    for (let r = row + dir; r >= 0 && r < ROWS; r += dir) {
                        if (boardState[r][col] === enemyGeneral && !blocked) {
                            moves.push({ row: r, col: col });
                            break;
                        }
                        if (boardState[r][col] !== EMPTY) blocked = true;
                    }
                    break;
                case 2:
                    const aMinRow = isRedPiece ? 7 : 0;
                    const aMaxRow = isRedPiece ? 9 : 2;
                    [[1, 1], [1, -1], [-1, 1], [-1, -1]].forEach(([dr, dc]) => {
                        const nr = row + dr, nc = col + dc;
                        if (nr >= aMinRow && nr <= aMaxRow && nc >= 3 && nc <= 5 && canMoveTo(nr, nc)) {
                            moves.push({ row: nr, col: nc });
                        }
                    });
                    break;
                case 3:
                    const eMinRow = isRedPiece ? 5 : 0;
                    const eMaxRow = isRedPiece ? 9 : 4;
                    [[2, 2, 1, 1], [2, -2, 1, -1], [-2, 2, -1, 1], [-2, -2, -1, -1]].forEach(([dr, dc, br, bc]) => {
                        const nr = row + dr, nc = col + dc;
                        const blockR = row + br, blockC = col + bc;
                        if (nr >= eMinRow && nr <= eMaxRow && nc >= 0 && nc < COLS &&
                            boardState[blockR][blockC] === EMPTY && canMoveTo(nr, nc)) {
                            moves.push({ row: nr, col: nc });
                        }
                    });
                    break;
                case 4:
                    [[2, 1, 1, 0], [2, -1, 1, 0], [-2, 1, -1, 0], [-2, -1, -1, 0],
                     [1, 2, 0, 1], [1, -2, 0, -1], [-1, 2, 0, 1], [-1, -2, 0, -1]
                    ].forEach(([dr, dc, br, bc]) => {
                        const nr = row + dr, nc = col + dc;
                        const blockR = row + br, blockC = col + bc;
                        if (blockR >= 0 && blockR < ROWS && blockC >= 0 && blockC < COLS &&
                            boardState[blockR][blockC] === EMPTY && canMoveTo(nr, nc)) {
                            moves.push({ row: nr, col: nc });
                        }
                    });
                    break;
                case 5:
                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                        for (let i = 1; i < 10; i++) {
                            const nr = row + dr * i, nc = col + dc * i;
                            if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) break;
                            if (boardState[nr][nc] === EMPTY) {
                                moves.push({ row: nr, col: nc });
                            } else {
                                if (isEnemy(piece, boardState[nr][nc])) moves.push({ row: nr, col: nc });
                                break;
                            }
                        }
                    });
                    break;
                case 6:
                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                        let jumped = false;
                        for (let i = 1; i < 10; i++) {
                            const nr = row + dr * i, nc = col + dc * i;
                            if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) break;
                            if (!jumped) {
                                if (boardState[nr][nc] === EMPTY) moves.push({ row: nr, col: nc });
                                else jumped = true;
                            } else {
                                if (boardState[nr][nc] !== EMPTY) {
                                    if (isEnemy(piece, boardState[nr][nc])) moves.push({ row: nr, col: nc });
                                    break;
                                }
                            }
                        }
                    });
                    break;
                case 7:
                    const forward = isRedPiece ? -1 : 1;
                    const crossedRiver = isRedPiece ? row <= 4 : row >= 5;
                    addMove(row + forward, col);
                    if (crossedRiver) {
                        addMove(row, col - 1);
                        addMove(row, col + 1);
                    }
                    break;
            }
            return moves;
        }

        function isInCheck(isRedPlayer, boardState = board) {
            let kingRow = -1, kingCol = -1;
            const kingPiece = isRedPlayer ? R_GENERAL : B_GENERAL;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (boardState[r][c] === kingPiece) {
                        kingRow = r; kingCol = c;
                        break;
                    }
                }
            }

            if (kingRow === -1) return true;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = boardState[r][c];
                    if (piece !== EMPTY && (isRedPlayer ? isBlack(piece) : isRed(piece))) {
                        const moves = getValidMoves(r, c, boardState);
                        if (moves.some(m => m.row === kingRow && m.col === kingCol)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function makeMoveOnBoard(fromRow, fromCol, toRow, toCol, boardState) {
            const captured = boardState[toRow][toCol];
            boardState[toRow][toCol] = boardState[fromRow][fromCol];
            boardState[fromRow][fromCol] = EMPTY;
            return captured;
        }

        function undoMoveOnBoard(fromRow, fromCol, toRow, toCol, captured, boardState) {
            boardState[fromRow][fromCol] = boardState[toRow][toCol];
            boardState[toRow][toCol] = captured;
        }

        function getLegalMoves(row, col, boardState = board) {
            const piece = boardState[row][col];
            const isRedPiece = isRed(piece);
            const moves = getValidMoves(row, col, boardState);

            return moves.filter(move => {
                const testBoard = boardState.map(r => [...r]);
                makeMoveOnBoard(row, col, move.row, move.col, testBoard);
                return !isInCheck(isRedPiece, testBoard);
            });
        }

        function hasLegalMoves(isRedPlayer, boardState = board) {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = boardState[r][c];
                    if (piece !== EMPTY && (isRedPlayer ? isRed(piece) : isBlack(piece))) {
                        if (getLegalMoves(r, c, boardState).length > 0) return true;
                    }
                }
            }
            return false;
        }

        canvas.addEventListener('click', (e) => {
            if (gameOver || currentPlayer !== myColor || !gameStarted) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const col = Math.round((x - MARGIN) / CELL_SIZE);
            const row = Math.round((y - MARGIN) / CELL_SIZE);

            if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return;

            const clickedPiece = board[row][col];

            // Check if clicking on a valid move
            const moveIndex = validMoves.findIndex(m => m.row === row && m.col === col);
            if (moveIndex !== -1 && selectedPiece) {
                const captured = board[row][col];
                const newBoard = board.map(r => [...r]);
                makeMoveOnBoard(selectedPiece.row, selectedPiece.col, row, col, newBoard);

                const newLastMove = {
                    fromRow: selectedPiece.row,
                    fromCol: selectedPiece.col,
                    toRow: row,
                    toCol: col
                };

                const nextPlayer = myColor === 'red' ? 'black' : 'red';
                const opponentIsRed = nextPlayer === 'red';
                const inCheck = isInCheck(opponentIsRed, newBoard);
                const opponentHasMoves = hasLegalMoves(opponentIsRed, newBoard);

                let isGameOver = false;
                let winner = null;

                if (captured === B_GENERAL || captured === R_GENERAL || !opponentHasMoves) {
                    isGameOver = true;
                    winner = myColor;
                }

                // Play local sound
                if (captured !== EMPTY) {
                    playSound('capture');
                } else {
                    playSound('move');
                }
                if (inCheck && !isGameOver) {
                    playSound('check');
                }
                if (isGameOver) {
                    playSound('victory');
                }

                // Update Firebase
                gameRef.update({
                    board: newBoard,
                    currentPlayer: nextPlayer,
                    lastMove: newLastMove,
                    lastMoveBy: myColor,
                    lastMoveWasCapture: captured !== EMPTY,
                    inCheck: inCheck,
                    gameOver: isGameOver,
                    winner: winner
                });

                selectedPiece = null;
                validMoves = [];
                return;
            }

            // Select a piece
            if (isMyPiece(clickedPiece)) {
                selectedPiece = { row, col };
                validMoves = getLegalMoves(row, col);
                playSound('select');
                drawBoard();
            } else {
                selectedPiece = null;
                validMoves = [];
                drawBoard();
            }
        });
    </script>
</body>
</html>
