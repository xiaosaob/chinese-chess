<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ä¸­å›½è±¡æ£‹ - åœ¨çº¿å¯¹æˆ˜</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        html, body {
            overflow-x: hidden;
            touch-action: manipulation;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Microsoft YaHei', 'SimHei', -apple-system, sans-serif;
        }
        .game-container {
            text-align: center;
            padding: 10px;
            width: 100%;
            max-width: 600px;
        }
        h1 {
            color: #f4d03f;
            margin-bottom: 8px;
            font-size: clamp(24px, 6vw, 32px);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .status {
            color: #fff;
            font-size: clamp(16px, 4vw, 20px);
            margin-bottom: 8px;
            min-height: 28px;
        }
        .player-info {
            color: #4ecca3;
            font-size: clamp(14px, 3.5vw, 16px);
            margin-bottom: 8px;
        }
        .board-container {
            display: inline-block;
            padding: clamp(8px, 2vw, 20px);
            background: #d4a056;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 100%;
            overflow: hidden;
        }
        canvas {
            cursor: pointer;
            touch-action: none;
            max-width: 100%;
            height: auto;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
        }
        button {
            padding: 12px 20px;
            font-size: clamp(14px, 3.5vw, 18px);
            background: #c0392b;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            transition: background 0.3s;
            touch-action: manipulation;
            min-height: 44px;
        }
        button:hover, button:active {
            background: #e74c3c;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .btn-google {
            background: #4285f4;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 0 auto 15px;
        }
        .btn-google:hover {
            background: #357abd;
        }
        .btn-guest {
            background: #95a5a6;
            display: block;
            width: 100%;
            margin: 10px auto;
        }
        .btn-guest:hover {
            background: #7f8c8d;
        }
        .btn-logout {
            background: #666;
            padding: 8px 15px;
            font-size: 14px;
        }
        .lobby {
            background: rgba(0,0,0,0.8);
            padding: clamp(20px, 5vw, 40px);
            border-radius: 15px;
            max-width: 500px;
            width: calc(100% - 20px);
            margin: 0 auto;
        }
        .lobby h2 {
            color: #f4d03f;
            margin-bottom: 15px;
            font-size: clamp(20px, 5vw, 28px);
        }
        .lobby p {
            color: #fff;
            margin-bottom: 12px;
            font-size: clamp(14px, 3.5vw, 16px);
        }
        .lobby input {
            padding: 12px 15px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            width: 100%;
            margin-bottom: 12px;
            text-align: center;
            min-height: 44px;
        }
        .share-link {
            background: #2c3e50;
            padding: 12px;
            border-radius: 5px;
            margin: 12px 0;
            word-break: break-all;
            font-size: clamp(12px, 3vw, 14px);
        }
        .share-link a {
            color: #3498db;
            text-decoration: none;
        }
        .waiting {
            color: #f4d03f;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 100;
        }
        .connected {
            background: #27ae60;
            color: white;
        }
        .disconnected {
            background: #c0392b;
            color: white;
        }
        .game-area {
            display: none;
        }
        .copy-btn {
            padding: 10px 20px;
            font-size: clamp(14px, 3.5vw, 16px);
            background: #3498db;
        }
        .copy-btn:hover, .copy-btn:active {
            background: #2980b9;
        }

        /* User profile styles */
        .user-profile {
            background: #2c3e50;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            text-align: left;
        }
        .user-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid #f4d03f;
        }
        .user-info {
            flex: 1;
        }
        .user-name {
            color: #f4d03f;
            font-size: 18px;
            font-weight: bold;
        }
        .user-stats {
            color: #aaa;
            font-size: 14px;
            margin-top: 5px;
        }
        .user-stats span {
            margin-right: 10px;
        }
        .win { color: #27ae60; }
        .loss { color: #c0392b; }
        .draw { color: #f39c12; }

        /* Leaderboard styles */
        .leaderboard {
            background: #2c3e50;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        .leaderboard h3 {
            color: #f4d03f;
            margin-bottom: 10px;
            font-size: 18px;
        }
        .leaderboard-item {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #3a4a5c;
            gap: 10px;
        }
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        .leaderboard-rank {
            width: 30px;
            font-weight: bold;
            color: #f4d03f;
        }
        .leaderboard-rank.gold { color: #ffd700; }
        .leaderboard-rank.silver { color: #c0c0c0; }
        .leaderboard-rank.bronze { color: #cd7f32; }
        .leaderboard-avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
        }
        .leaderboard-name {
            flex: 1;
            color: #fff;
            font-size: 14px;
        }
        .leaderboard-score {
            color: #4ecca3;
            font-weight: bold;
        }

        /* Login screen */
        .login-section {
            text-align: center;
        }
        .login-section p {
            color: #888;
            margin-bottom: 20px;
        }
        .auth-divider {
            display: flex;
            align-items: center;
            margin: 20px 0;
            color: #666;
        }
        .auth-divider::before,
        .auth-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: #444;
        }
        .auth-divider span {
            padding: 0 15px;
            font-size: 14px;
        }
        .auth-form input {
            width: 100%;
            padding: 12px 15px;
            margin-bottom: 10px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            text-align: left;
        }
        .auth-form input::placeholder {
            color: #999;
        }
        .btn-email {
            background: #27ae60;
            width: 100%;
            margin-bottom: 10px;
        }
        .btn-email:hover {
            background: #2ecc71;
        }
        .auth-toggle {
            color: #3498db;
            cursor: pointer;
            font-size: 14px;
            text-decoration: underline;
        }
        .auth-toggle:hover {
            color: #5dade2;
        }
        .auth-error {
            color: #e74c3c;
            font-size: 14px;
            margin-bottom: 10px;
            display: none;
        }
        .forgot-password {
            color: #888;
            font-size: 13px;
            cursor: pointer;
            margin-top: 5px;
        }
        .forgot-password:hover {
            color: #3498db;
        }
        .guest-prompt {
            background: rgba(241, 196, 15, 0.2);
            border: 1px solid #f1c40f;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 15px;
        }
        .guest-prompt p {
            color: #f1c40f;
            font-size: 13px;
            margin: 0;
        }
        .guest-badge {
            background: #95a5a6;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 8px;
            vertical-align: middle;
        }
        .upgrade-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .upgrade-modal.show {
            display: flex;
        }
        .upgrade-content {
            background: #1a1a2e;
            padding: 30px;
            border-radius: 15px;
            max-width: 400px;
            width: calc(100% - 40px);
            text-align: center;
        }
        .upgrade-content h3 {
            color: #f4d03f;
            margin-bottom: 15px;
        }
        .upgrade-content p {
            color: #aaa;
            margin-bottom: 20px;
            font-size: 14px;
        }
        .upgrade-content .auth-form {
            text-align: left;
        }
        .close-modal {
            background: #666;
            margin-top: 10px;
        }

        /* Game mode selection */
        .mode-selection {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }
        .mode-card {
            flex: 1;
            background: #2c3e50;
            border: 2px solid #3a4a5c;
            border-radius: 10px;
            padding: 20px 15px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .mode-card:hover {
            border-color: #4ecca3;
            transform: translateY(-2px);
        }
        .mode-card.selected {
            border-color: #4ecca3;
            background: rgba(78, 204, 163, 0.1);
        }
        .mode-card .icon {
            font-size: 36px;
            margin-bottom: 10px;
        }
        .mode-card .title {
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .mode-card .desc {
            color: #888;
            font-size: 12px;
        }
        .difficulty-select {
            margin: 15px 0;
            display: none;
        }
        .difficulty-select.show {
            display: block;
        }
        .difficulty-select label {
            color: #aaa;
            font-size: 14px;
            margin-right: 10px;
        }
        .difficulty-select select {
            padding: 8px 15px;
            font-size: 14px;
            border-radius: 5px;
            border: none;
            background: #3a4a5c;
            color: #fff;
        }

        /* Time control selection */
        .time-control {
            margin: 15px 0;
        }
        .time-control label {
            color: #aaa;
            font-size: 14px;
            display: block;
            margin-bottom: 8px;
        }
        .time-options {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .time-option {
            padding: 10px 20px;
            background: #3a4a5c;
            border: 2px solid #3a4a5c;
            border-radius: 8px;
            color: #aaa;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }
        .time-option:hover {
            border-color: #4ecca3;
        }
        .time-option.selected {
            border-color: #4ecca3;
            background: rgba(78, 204, 163, 0.2);
            color: #4ecca3;
        }
        /* Game timers display */
        .game-timers {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 0 10px;
        }
        .player-timer {
            background: #2c3e50;
            padding: 8px 15px;
            border-radius: 8px;
            min-width: 120px;
        }
        .player-timer.active {
            background: #27ae60;
        }
        .player-timer.warning {
            background: #f39c12;
        }
        .player-timer.danger {
            background: #c0392b;
            animation: pulse 0.5s infinite;
        }
        .timer-label {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 4px;
        }
        .player-timer.active .timer-label,
        .player-timer.warning .timer-label,
        .player-timer.danger .timer-label {
            color: rgba(255,255,255,0.8);
        }
        .timer-display {
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            font-family: monospace;
        }
        .move-timer {
            font-size: 12px;
            color: #f39c12;
            margin-top: 4px;
        }
        .player-timer.danger .move-timer {
            color: #fff;
        }
        .refresh-btn {
            background: none;
            border: none;
            color: #4ecca3;
            cursor: pointer;
            font-size: 14px;
            padding: 0;
            margin-left: auto;
        }
        .refresh-btn:hover {
            color: #5fd9b0;
        }

        /* Game player names */
        .game-players {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 0 10px;
        }
        .game-player {
            background: #2c3e50;
            padding: 8px 15px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .game-player img {
            width: 24px;
            height: 24px;
            border-radius: 50%;
        }
        .game-player.red { border: 2px solid #c41e3a; }
        .game-player.black { border: 2px solid #333; }
        .game-player.active {
            box-shadow: 0 0 10px rgba(78, 204, 163, 0.8);
            border-color: #4ecca3;
        }

        /* Tabs */
        .tabs {
            display: flex;
            margin-bottom: 15px;
            border-radius: 5px;
            overflow: hidden;
        }
        .tab {
            flex: 1;
            padding: 10px;
            background: #3a4a5c;
            color: #aaa;
            border: none;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            min-height: 40px;
        }
        .tab.active {
            background: #4ecca3;
            color: #1a1a2e;
            font-weight: bold;
        }

        /* Mobile-specific adjustments */
        @media (max-width: 520px) {
            .game-container {
                padding: 5px;
            }
            .board-container {
                padding: 5px;
                border-radius: 8px;
            }
            .controls {
                padding: 0 5px;
            }
            button {
                padding: 10px 15px;
                flex: 1 1 auto;
                min-width: 80px;
            }
            .user-profile {
                padding: 10px;
            }
            .user-avatar {
                width: 40px;
                height: 40px;
            }
            .game-players {
                flex-direction: column;
                gap: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="connection-status disconnected" id="connectionStatus">æœªè¿æ¥</div>

    <div class="game-container">
        <!-- Login Screen -->
        <div class="lobby" id="loginScreen">
            <h2>ä¸­å›½è±¡æ£‹ - åœ¨çº¿å¯¹æˆ˜</h2>
            <div class="login-section">
                <p>å¿«é€Ÿå¼€å§‹æ¸¸æˆ</p>
                <button class="btn-guest" onclick="signInAsGuest()">
                    ç«‹å³å¼€å§‹
                </button>

                <div class="auth-divider"><span>æˆ–ç™»å½•ä»¥ä¿å­˜æˆ˜ç»©</span></div>

                <button class="btn-google" onclick="signInWithGoogle()">
                    <svg width="18" height="18" viewBox="0 0 18 18"><path fill="#fff" d="M16.51 8H8.98v3h4.3c-.18 1-.74 1.48-1.6 2.04v2.01h2.6a7.8 7.8 0 0 0 2.38-5.88c0-.57-.05-.66-.15-1.18z"/><path fill="#fff" d="M8.98 17c2.16 0 3.97-.72 5.3-1.94l-2.6-2a4.8 4.8 0 0 1-7.18-2.54H1.83v2.07A8 8 0 0 0 8.98 17z"/><path fill="#fff" d="M4.5 10.52a4.8 4.8 0 0 1 0-3.04V5.41H1.83a8 8 0 0 0 0 7.18l2.67-2.07z"/><path fill="#fff" d="M8.98 4.18c1.17 0 2.23.4 3.06 1.2l2.3-2.3A8 8 0 0 0 1.83 5.4L4.5 7.49a4.77 4.77 0 0 1 4.48-3.3z"/></svg>
                    ä½¿ç”¨ Google ç™»å½•
                </button>

                <div class="auth-divider"><span>æˆ–ä½¿ç”¨é‚®ç®±</span></div>

                <div class="auth-form">
                    <div class="auth-error" id="authError"></div>
                    <input type="text" id="displayNameInput" placeholder="æ˜µç§° (ä»…æ³¨å†Œæ—¶éœ€è¦)" style="display: none;">
                    <input type="email" id="emailInput" placeholder="é‚®ç®±åœ°å€">
                    <input type="password" id="passwordInput" placeholder="å¯†ç  (è‡³å°‘6ä½)">
                    <button class="btn-email" id="authBtn" onclick="handleEmailAuth()">ç™»å½•</button>
                    <p>
                        <span class="auth-toggle" id="authToggle" onclick="toggleAuthMode()">æ²¡æœ‰è´¦å·ï¼Ÿç‚¹å‡»æ³¨å†Œ</span>
                    </p>
                    <p class="forgot-password" onclick="handleForgotPassword()">å¿˜è®°å¯†ç ï¼Ÿ</p>
                </div>
            </div>
        </div>

        <!-- Lobby -->
        <div class="lobby" id="lobby" style="display: none;">
            <h2>ä¸­å›½è±¡æ£‹ - åœ¨çº¿å¯¹æˆ˜</h2>

            <!-- User Profile -->
            <div class="user-profile" id="userProfile">
                <img class="user-avatar" id="userAvatar" src="" alt="avatar">
                <div class="user-info">
                    <div class="user-name" id="userName">ç©å®¶</div>
                    <div class="user-stats">
                        <span class="win" id="userWins">èƒœ: 0</span>
                        <span class="loss" id="userLosses">è´Ÿ: 0</span>
                        <span class="draw" id="userDraws">å’Œ: 0</span>
                    </div>
                </div>
                <button class="btn-logout" onclick="signOut()">ç™»å‡º</button>
            </div>
            <!-- Guest upgrade prompt -->
            <div class="guest-prompt" id="guestPrompt" style="display: none;">
                <p>æ¸¸å®¢æ•°æ®å°†åœ¨ç™»å‡ºåä¸¢å¤±ï¼Œ<span class="auth-toggle" onclick="showUpgradeModal()">ç‚¹å‡»å‡çº§è´¦å·</span>ä¿å­˜æˆ˜ç»©</p>
            </div>

            <!-- Tabs -->
            <div class="tabs">
                <button class="tab active" onclick="showTab('play')">å¼€å§‹æ¸¸æˆ</button>
                <button class="tab" onclick="showTab('leaderboard')">æ’è¡Œæ¦œ</button>
            </div>

            <!-- Play Tab -->
            <div id="playTab">
                <!-- Mode Selection -->
                <div class="mode-selection" id="modeSelection">
                    <div class="mode-card" onclick="selectMode('ai')" id="modeAI">
                        <div class="icon">ğŸ¤–</div>
                        <div class="title">äººæœºå¯¹æˆ˜</div>
                        <div class="desc">ä¸AIå¯¹å¼ˆ</div>
                    </div>
                    <div class="mode-card" onclick="selectMode('online')" id="modeOnline">
                        <div class="icon">ğŸ‘¥</div>
                        <div class="title">åœ¨çº¿å¯¹æˆ˜</div>
                        <div class="desc">ä¸æœ‹å‹å¯¹å¼ˆ</div>
                    </div>
                </div>

                <!-- AI Mode Options (hidden by default) -->
                <div class="difficulty-select" id="aiOptions" style="display: none;">
                    <h3 style="color: #f4d03f; margin-bottom: 15px;">ğŸ¤– äººæœºå¯¹æˆ˜</h3>
                    <label>éš¾åº¦:</label>
                    <select id="aiDifficulty">
                        <option value="2">ç®€å•</option>
                        <option value="3" selected>ä¸­ç­‰</option>
                        <option value="4">å›°éš¾</option>
                    </select>
                    <div class="time-control" style="margin-top: 15px;">
                        <label>é€‰æ‹©æ—¶é—´é™åˆ¶ (æ¯æ–¹æ€»ç”¨æ—¶)</label>
                        <div class="time-options" id="aiTimeOptions">
                            <div class="time-option" onclick="selectAITimeControl(5)">5åˆ†é’Ÿ</div>
                            <div class="time-option selected" onclick="selectAITimeControl(10)">10åˆ†é’Ÿ</div>
                            <div class="time-option" onclick="selectAITimeControl(20)">20åˆ†é’Ÿ</div>
                        </div>
                    </div>
                    <button onclick="startAIGame()" style="margin-top: 15px;">å¼€å§‹æ¸¸æˆ</button>
                    <button onclick="goBackToModeSelection()" style="margin-top: 10px; background: #666;">è¿”å›</button>
                </div>

                <!-- Online Mode Options (hidden by default) -->
                <div id="createSection" style="display: none;">
                    <h3 style="color: #f4d03f; margin-bottom: 15px;">ğŸ‘¥ åœ¨çº¿å¯¹æˆ˜</h3>
                    <div class="time-control">
                        <label>é€‰æ‹©æ—¶é—´é™åˆ¶ (æ¯æ–¹æ€»ç”¨æ—¶)</label>
                        <div class="time-options">
                            <div class="time-option" onclick="selectTimeControl(5)">5åˆ†é’Ÿ</div>
                            <div class="time-option selected" onclick="selectTimeControl(10)">10åˆ†é’Ÿ</div>
                            <div class="time-option" onclick="selectTimeControl(20)">20åˆ†é’Ÿ</div>
                        </div>
                    </div>
                    <button onclick="createGame()" style="margin-top: 15px;">åˆ›å»ºæ–°æ¸¸æˆ</button>

                    <p style="margin: 20px 0; color: #888;">- æˆ–åŠ å…¥å·²æœ‰æ¸¸æˆ -</p>
                    <input type="text" id="joinRoomId" placeholder="è¾“å…¥æˆ¿é—´å·">
                    <button onclick="joinGame()">åŠ å…¥æ¸¸æˆ</button>
                    <button onclick="goBackToModeSelection()" style="margin-top: 10px; background: #666;">è¿”å›</button>
                </div>

            </div>

            <!-- Leaderboard Tab -->
            <div id="leaderboardTab" style="display: none;">
                <div class="leaderboard" id="leaderboard">
                    <h3>ğŸ† æ’è¡Œæ¦œ</h3>
                    <div id="leaderboardList">
                        <p style="color: #888; text-align: center;">åŠ è½½ä¸­...</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Game Area -->
        <div class="game-area" id="gameArea">
            <h1>ä¸­å›½è±¡æ£‹</h1>
            <div class="game-timers" id="gameTimers">
                <div class="player-timer" id="redTimer">
                    <div class="timer-label">çº¢æ–¹</div>
                    <div class="timer-display" id="redTimeDisplay">10:00</div>
                    <div class="move-timer" id="redMoveTimer"></div>
                </div>
                <div class="player-timer" id="blackTimer">
                    <div class="timer-label">é»‘æ–¹</div>
                    <div class="timer-display" id="blackTimeDisplay">10:00</div>
                    <div class="move-timer" id="blackMoveTimer"></div>
                </div>
            </div>
            <div class="game-players" id="gamePlayers">
                <div class="game-player red" id="redPlayerInfo">
                    <img src="" alt="">
                    <span>çº¢æ–¹</span>
                </div>
                <div class="game-player black" id="blackPlayerInfo">
                    <img src="" alt="">
                    <span>é»‘æ–¹</span>
                </div>
            </div>
            <div class="status" id="status">çº¢æ–¹å…ˆè¡Œ</div>
            <!-- Share link section (shown when waiting for opponent) -->
            <div class="share-section" id="shareSection" style="display: none;">
                <div class="share-link">
                    <p style="color: #888; font-size: 14px; margin-bottom: 5px;">åˆ†äº«é“¾æ¥ç»™æœ‹å‹:</p>
                    <a id="gameShareLink" href="#" target="_blank" style="font-size: 12px;"></a>
                </div>
                <button class="copy-btn" onclick="copyGameLink()" style="margin-top: 8px; padding: 8px 15px; font-size: 14px;">å¤åˆ¶é“¾æ¥</button>
                <p style="margin-top: 8px; color: #888; font-size: 12px;">æˆ¿é—´å·: <span id="gameRoomId"></span></p>
            </div>
            <div class="board-container">
                <canvas id="board" width="520" height="580"></canvas>
            </div>
            <div class="controls">
                <button onclick="requestUndo()" id="undoBtn">æ‚”æ£‹</button>
                <button onclick="requestRematch()" id="rematchBtn" style="display:none;">å†æ¥ä¸€å±€</button>
                <button onclick="leaveGame()">ç¦»å¼€æ¸¸æˆ</button>
                <button id="soundBtn" onclick="toggleSound()">å…³é—­éŸ³æ•ˆ</button>
            </div>
        </div>
    </div>

    <!-- Upgrade Modal for Guests -->
    <div class="upgrade-modal" id="upgradeModal">
        <div class="upgrade-content">
            <h3>å‡çº§è´¦å·</h3>
            <p>å…³è”é‚®ç®±ä»¥æ°¸ä¹…ä¿å­˜ä½ çš„æˆ˜ç»©</p>
            <div class="auth-form">
                <div class="auth-error" id="upgradeError"></div>
                <input type="email" id="upgradeEmail" placeholder="é‚®ç®±åœ°å€">
                <input type="password" id="upgradePassword" placeholder="è®¾ç½®å¯†ç  (è‡³å°‘6ä½)">
                <button class="btn-email" onclick="upgradeGuestAccount()">å‡çº§è´¦å·</button>
                <button class="close-modal" onclick="hideUpgradeModal()">å–æ¶ˆ</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>

    <script>
        // ============================================
        // FIREBASE CONFIGURATION
        // ============================================
        const firebaseConfig = {
            apiKey: "AIzaSyDsV1zjfCwYXoq6Ua3AZ4QVbLt1Sdgyd0Y",
            authDomain: "chinese-chess-9a981.firebaseapp.com",
            databaseURL: "https://chinese-chess-9a981-default-rtdb.firebaseio.com",
            projectId: "chinese-chess-9a981",
            storageBucket: "chinese-chess-9a981.firebasestorage.app",
            messagingSenderId: "1085517521136",
            appId: "1:1085517521136:web:636b9648a132ce740da235",
            measurementId: "G-Z9Y2LS56EL"
        };

        // Initialize Firebase
        let db = null;
        let auth = null;
        let currentUser = null;
        let userProfile = null;
        let gameRef = null;
        let roomId = null;
        let myColor = null;
        let gameStarted = false;
        let opponentProfile = null;
        let isAIGame = false;
        let aiDepth = 3;
        let aiThinking = false;

        // Timer variables
        let selectedTimeControl = 10; // minutes
        let redTimeRemaining = 0; // ms
        let blackTimeRemaining = 0; // ms
        let redMoveCount = 0;
        let blackMoveCount = 0;
        let currentMoveStartTime = 0;
        let moveTimeLimit = 0; // ms
        let gameTimerInterval = null;
        let lastTimerUpdate = 0;

        try {
            firebase.initializeApp(firebaseConfig);
            db = firebase.database();
            auth = firebase.auth();
            document.getElementById('connectionStatus').className = 'connection-status connected';
            document.getElementById('connectionStatus').textContent = 'å·²è¿æ¥';
        } catch (e) {
            console.error('Firebase initialization failed:', e);
            alert('Firebase é…ç½®é”™è¯¯ï¼Œè¯·æ£€æŸ¥é…ç½®ä¿¡æ¯');
        }

        // ============================================
        // AUTHENTICATION
        // ============================================
        let isSignUpMode = false;

        function signInWithGoogle() {
            const provider = new firebase.auth.GoogleAuthProvider();
            auth.signInWithPopup(provider).catch((error) => {
                console.error('Login error:', error);
                showAuthError('Googleç™»å½•å¤±è´¥: ' + getErrorMessage(error.code));
            });
        }

        function signOut() {
            auth.signOut();
        }

        async function signInAsGuest() {
            try {
                // Show loading state
                const btn = document.querySelector('.btn-guest');
                btn.textContent = 'ç™»å½•ä¸­...';
                btn.disabled = true;

                console.log('Attempting anonymous sign in...');
                const result = await auth.signInAnonymously();
                console.log('Anonymous sign in successful:', result.user.uid);
                // Button will be hidden when auth state changes and login screen hides
            } catch (error) {
                console.error('Guest login error:', error);
                alert('æ¸¸å®¢ç™»å½•å¤±è´¥: ' + (error.message || error.code));
                showAuthError('æ¸¸å®¢ç™»å½•å¤±è´¥: ' + getErrorMessage(error.code));

                // Reset button
                const btn = document.querySelector('.btn-guest');
                btn.textContent = 'ç«‹å³å¼€å§‹';
                btn.disabled = false;
            }
        }

        function toggleAuthMode() {
            isSignUpMode = !isSignUpMode;
            const btn = document.getElementById('authBtn');
            const toggle = document.getElementById('authToggle');
            const nameInput = document.getElementById('displayNameInput');

            if (isSignUpMode) {
                btn.textContent = 'æ³¨å†Œ';
                toggle.textContent = 'å·²æœ‰è´¦å·ï¼Ÿç‚¹å‡»ç™»å½•';
                nameInput.style.display = 'block';
            } else {
                btn.textContent = 'ç™»å½•';
                toggle.textContent = 'æ²¡æœ‰è´¦å·ï¼Ÿç‚¹å‡»æ³¨å†Œ';
                nameInput.style.display = 'none';
            }
            hideAuthError();
        }

        function showAuthError(message) {
            const errorEl = document.getElementById('authError');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        function hideAuthError() {
            document.getElementById('authError').style.display = 'none';
        }

        function getErrorMessage(code) {
            const messages = {
                'auth/email-already-in-use': 'è¯¥é‚®ç®±å·²è¢«æ³¨å†Œ',
                'auth/invalid-email': 'é‚®ç®±æ ¼å¼ä¸æ­£ç¡®',
                'auth/operation-not-allowed': 'é‚®ç®±ç™»å½•æœªå¯ç”¨',
                'auth/weak-password': 'å¯†ç å¤ªå¼±ï¼Œè¯·è‡³å°‘ä½¿ç”¨6ä½å­—ç¬¦',
                'auth/user-disabled': 'è¯¥è´¦æˆ·å·²è¢«ç¦ç”¨',
                'auth/user-not-found': 'ç”¨æˆ·ä¸å­˜åœ¨',
                'auth/wrong-password': 'å¯†ç é”™è¯¯',
                'auth/invalid-credential': 'é‚®ç®±æˆ–å¯†ç é”™è¯¯',
                'auth/too-many-requests': 'å°è¯•æ¬¡æ•°è¿‡å¤šï¼Œè¯·ç¨åå†è¯•'
            };
            return messages[code] || 'æ“ä½œå¤±è´¥ï¼Œè¯·é‡è¯•';
        }

        async function handleEmailAuth() {
            const email = document.getElementById('emailInput').value.trim();
            const password = document.getElementById('passwordInput').value;
            const displayName = document.getElementById('displayNameInput').value.trim();

            hideAuthError();

            if (!email || !password) {
                showAuthError('è¯·è¾“å…¥é‚®ç®±å’Œå¯†ç ');
                return;
            }

            if (isSignUpMode && !displayName) {
                showAuthError('è¯·è¾“å…¥æ˜µç§°');
                return;
            }

            try {
                if (isSignUpMode) {
                    // Sign up
                    const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                    // Update display name
                    await userCredential.user.updateProfile({
                        displayName: displayName,
                        photoURL: generateAvatarUrl(displayName)
                    });
                    // Reload to get updated profile
                    await userCredential.user.reload();
                } else {
                    // Sign in
                    await auth.signInWithEmailAndPassword(email, password);
                }
            } catch (error) {
                console.error('Auth error:', error);
                showAuthError(getErrorMessage(error.code));
            }
        }

        function generateAvatarUrl(name) {
            // Generate a simple avatar using UI Avatars API
            const encodedName = encodeURIComponent(name || 'Player');
            return `https://ui-avatars.com/api/?name=${encodedName}&background=random&color=fff&size=100`;
        }

        async function handleForgotPassword() {
            const email = document.getElementById('emailInput').value.trim();

            if (!email) {
                showAuthError('è¯·å…ˆè¾“å…¥é‚®ç®±åœ°å€');
                return;
            }

            try {
                await auth.sendPasswordResetEmail(email);
                alert('å¯†ç é‡ç½®é‚®ä»¶å·²å‘é€åˆ° ' + email + 'ï¼Œè¯·æŸ¥æ”¶');
            } catch (error) {
                console.error('Password reset error:', error);
                showAuthError(getErrorMessage(error.code));
            }
        }

        // Handle Enter key in password field
        document.addEventListener('DOMContentLoaded', () => {
            const passwordInput = document.getElementById('passwordInput');
            if (passwordInput) {
                passwordInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        handleEmailAuth();
                    }
                });
            }
        });

        auth.onAuthStateChanged(async (user) => {
            console.log('Auth state changed:', user ? user.uid : 'no user');
            try {
                if (user) {
                    currentUser = user;
                    console.log('Loading user profile...');
                    await loadOrCreateUserProfile(user);
                    console.log('User profile loaded');
                    document.getElementById('loginScreen').style.display = 'none';
                    document.getElementById('lobby').style.display = 'block';
                    updateProfileUI();
                    loadLeaderboard();

                    // Check URL for room ID after login
                    const urlParams = new URLSearchParams(window.location.search);
                    const urlRoomId = urlParams.get('room');
                    if (urlRoomId) {
                        document.getElementById('joinRoomId').value = urlRoomId;
                        selectMode('online');
                        joinGame();
                    }
                } else {
                    currentUser = null;
                    userProfile = null;
                    document.getElementById('loginScreen').style.display = 'block';
                    document.getElementById('lobby').style.display = 'none';

                    // Reset guest login button state
                    const guestBtn = document.querySelector('.btn-guest');
                    if (guestBtn) {
                        guestBtn.textContent = 'ç«‹å³å¼€å§‹';
                        guestBtn.disabled = false;
                    }
                }
            } catch (error) {
                console.error('Error in auth state handler:', error);
                alert('ç™»å½•å¤„ç†å‡ºé”™: ' + error.message);
                // Reset button on error
                const guestBtn = document.querySelector('.btn-guest');
                if (guestBtn) {
                    guestBtn.textContent = 'ç«‹å³å¼€å§‹';
                    guestBtn.disabled = false;
                }
            }
        });

        // Generate fancy guest names related to Chinese chess and ancient China
        function generateGuestName(uid) {
            const titles = [
                // Chess pieces
                'å°†å†›', 'å£«å®˜', 'è±¡å¸ˆ', 'è½¦ç¥', 'é©¬ç‹', 'ç‚®æ‰‹', 'å…µåœ£',
                // Famous strategists and generals
                'å§é¾™', 'å‡¤é›', 'è™å°†', 'é¾™éª‘', 'ç™½è¢', 'é“¶æª', 'é‡‘ç”²',
                // Chess masters
                'æ£‹ä»™', 'æ£‹åœ£', 'æ£‹ç‹', 'æ£‹ä¾ ', 'æ£‹é­‚', 'æ£‹ç¥', 'å¼ˆè€…',
                // Ancient titles
                'å‰‘å®¢', 'è°‹å£«', 'å†›å¸ˆ', 'å¤§å°†', 'å…ˆé”‹', 'æŠ¤å«', 'ä¾ å®¢',
                // Mythical
                'é’é¾™', 'ç™½è™', 'æœ±é›€', 'ç„æ­¦', 'éº’éºŸ', 'å‡¤å‡°', 'ç¥é¾™'
            ];
            // Use uid to pick a consistent name for this user
            const index = parseInt(uid.substring(0, 8), 16) % titles.length;
            return titles[index];
        }

        async function loadOrCreateUserProfile(user) {
            const userRef = db.ref('users/' + user.uid);
            const snapshot = await userRef.once('value');

            // Generate name and avatar for guests/email users
            const isGuest = user.isAnonymous;
            const guestName = generateGuestName(user.uid);
            const displayName = user.displayName || user.email?.split('@')[0] || guestName;
            const photoURL = user.photoURL || generateAvatarUrl(displayName);

            if (snapshot.exists()) {
                userProfile = snapshot.val();
                // Keep existing name for guests if already set, otherwise update
                const updatedName = isGuest && userProfile.displayName ? userProfile.displayName : displayName;
                await userRef.update({
                    displayName: updatedName,
                    photoURL: photoURL,
                    isGuest: isGuest
                });
                userProfile.displayName = updatedName;
                userProfile.photoURL = photoURL;
                userProfile.isGuest = isGuest;
            } else {
                userProfile = {
                    displayName: displayName,
                    photoURL: photoURL,
                    wins: 0,
                    losses: 0,
                    draws: 0,
                    gamesPlayed: 0,
                    isGuest: isGuest,
                    createdAt: Date.now()
                };
                await userRef.set(userProfile);
            }
        }

        function updateProfileUI() {
            if (userProfile) {
                document.getElementById('userAvatar').src = userProfile.photoURL || 'https://via.placeholder.com/50';

                const nameEl = document.getElementById('userName');
                const guestPrompt = document.getElementById('guestPrompt');

                if (userProfile.isGuest) {
                    nameEl.innerHTML = (userProfile.displayName || 'æ¸¸å®¢') + '<span class="guest-badge">æ¸¸å®¢</span>';
                    guestPrompt.style.display = 'block';
                } else {
                    nameEl.textContent = userProfile.displayName || 'ç©å®¶';
                    guestPrompt.style.display = 'none';
                }

                document.getElementById('userWins').textContent = 'èƒœ: ' + (userProfile.wins || 0);
                document.getElementById('userLosses').textContent = 'è´Ÿ: ' + (userProfile.losses || 0);
                document.getElementById('userDraws').textContent = 'å’Œ: ' + (userProfile.draws || 0);
            }
        }

        function showUpgradeModal() {
            document.getElementById('upgradeModal').classList.add('show');
            document.getElementById('upgradeError').style.display = 'none';
        }

        function hideUpgradeModal() {
            document.getElementById('upgradeModal').classList.remove('show');
        }

        async function upgradeGuestAccount() {
            const email = document.getElementById('upgradeEmail').value.trim();
            const password = document.getElementById('upgradePassword').value;
            const errorEl = document.getElementById('upgradeError');

            errorEl.style.display = 'none';

            if (!email || !password) {
                errorEl.textContent = 'è¯·è¾“å…¥é‚®ç®±å’Œå¯†ç ';
                errorEl.style.display = 'block';
                return;
            }

            try {
                const credential = firebase.auth.EmailAuthProvider.credential(email, password);
                await currentUser.linkWithCredential(credential);

                // Update profile
                userProfile.isGuest = false;
                await db.ref('users/' + currentUser.uid).update({ isGuest: false });

                hideUpgradeModal();
                updateProfileUI();
                alert('è´¦å·å‡çº§æˆåŠŸï¼ä½ çš„æˆ˜ç»©å·²æ°¸ä¹…ä¿å­˜ã€‚');
            } catch (error) {
                console.error('Upgrade error:', error);
                errorEl.textContent = getErrorMessage(error.code);
                errorEl.style.display = 'block';
            }
        }

        async function updateUserStats(result) {
            if (!currentUser) return;

            const userRef = db.ref('users/' + currentUser.uid);
            const updates = {
                gamesPlayed: (userProfile.gamesPlayed || 0) + 1
            };

            if (result === 'win') {
                updates.wins = (userProfile.wins || 0) + 1;
                userProfile.wins = updates.wins;
            } else if (result === 'loss') {
                updates.losses = (userProfile.losses || 0) + 1;
                userProfile.losses = updates.losses;
            } else if (result === 'draw') {
                updates.draws = (userProfile.draws || 0) + 1;
                userProfile.draws = updates.draws;
            }

            userProfile.gamesPlayed = updates.gamesPlayed;
            await userRef.update(updates);
            updateProfileUI();

            // Update leaderboard
            await updateLeaderboard();
        }

        async function updateLeaderboard() {
            if (!currentUser || !userProfile) return;

            const score = (userProfile.wins || 0) * 3 + (userProfile.draws || 0);
            await db.ref('leaderboard/' + currentUser.uid).set({
                displayName: userProfile.displayName,
                photoURL: userProfile.photoURL,
                wins: userProfile.wins || 0,
                losses: userProfile.losses || 0,
                draws: userProfile.draws || 0,
                score: score
            });
        }

        async function loadLeaderboard() {
            const leaderboardRef = db.ref('leaderboard').orderByChild('score').limitToLast(20);
            leaderboardRef.on('value', (snapshot) => {
                const data = snapshot.val();
                const list = document.getElementById('leaderboardList');

                if (!data) {
                    list.innerHTML = '<p style="color: #888; text-align: center;">æš‚æ— æ•°æ®</p>';
                    return;
                }

                // Convert to array and sort by score descending
                const players = Object.entries(data)
                    .map(([uid, player]) => ({ uid, ...player }))
                    .sort((a, b) => b.score - a.score);

                list.innerHTML = players.map((player, index) => {
                    const rankClass = index === 0 ? 'gold' : index === 1 ? 'silver' : index === 2 ? 'bronze' : '';
                    const isMe = currentUser && player.uid === currentUser.uid;
                    return `
                        <div class="leaderboard-item" style="${isMe ? 'background: rgba(78,204,163,0.2);' : ''}">
                            <div class="leaderboard-rank ${rankClass}">${index + 1}</div>
                            <img class="leaderboard-avatar" src="${player.photoURL || 'https://via.placeholder.com/30'}" alt="">
                            <div class="leaderboard-name">${player.displayName || 'ç©å®¶'}${isMe ? ' (ä½ )' : ''}</div>
                            <div class="leaderboard-score">${player.score}åˆ†</div>
                        </div>
                    `;
                }).join('');
            });
        }

        // ============================================
        // UI HELPERS
        // ============================================
        let selectedGameMode = null; // No mode selected by default

        function showTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');

            document.getElementById('playTab').style.display = tab === 'play' ? 'block' : 'none';
            document.getElementById('leaderboardTab').style.display = tab === 'leaderboard' ? 'block' : 'none';
        }

        function selectMode(mode) {
            selectedGameMode = mode;

            // Hide mode selection cards
            document.getElementById('modeSelection').style.display = 'none';

            // Hide both sections first, then show the selected one
            document.getElementById('aiOptions').style.display = 'none';
            document.getElementById('createSection').style.display = 'none';

            if (mode === 'ai') {
                document.getElementById('aiOptions').style.display = 'block';
            } else if (mode === 'online') {
                document.getElementById('createSection').style.display = 'block';
            }
        }

        function goBackToModeSelection() {
            selectedGameMode = null;

            // Show mode selection cards
            document.getElementById('modeSelection').style.display = 'flex';

            // Hide both option sections
            document.getElementById('aiOptions').style.display = 'none';
            document.getElementById('createSection').style.display = 'none';
        }

        // ============================================
        // TIME CONTROL
        // ============================================
        let selectedAITimeControl = 10; // Default 10 minutes for AI games

        function selectTimeControl(minutes) {
            selectedTimeControl = minutes;
            document.querySelectorAll('#createSection .time-option').forEach(el => {
                el.classList.toggle('selected', el.textContent === minutes + 'åˆ†é’Ÿ');
            });
        }

        function selectAITimeControl(minutes) {
            selectedAITimeControl = minutes;
            document.querySelectorAll('#aiTimeOptions .time-option').forEach(el => {
                el.classList.toggle('selected', el.textContent === minutes + 'åˆ†é’Ÿ');
            });
        }

        function getMoveTimeLimit(moveCount) {
            // First 3 moves: 30 seconds, thereafter: 90 seconds
            return moveCount < 3 ? 30000 : 90000;
        }

        function initializeTimers(timeControlMinutes) {
            const totalTime = timeControlMinutes * 60 * 1000;
            redTimeRemaining = totalTime;
            blackTimeRemaining = totalTime;
            redMoveCount = 0;
            blackMoveCount = 0;
            currentMoveStartTime = Date.now();
            moveTimeLimit = getMoveTimeLimit(0);
            lastTimerUpdate = Date.now();

            updateTimerDisplay();
            startGameTimer();
        }

        function startGameTimer() {
            if (gameTimerInterval) {
                clearInterval(gameTimerInterval);
            }

            gameTimerInterval = setInterval(() => {
                if (gameOver || !gameStarted) {
                    clearInterval(gameTimerInterval);
                    return;
                }

                const now = Date.now();
                const elapsed = now - lastTimerUpdate;
                lastTimerUpdate = now;

                if (isAIGame) {
                    // AI game - track both timers locally
                    if (currentPlayer === 'red') {
                        redTimeRemaining -= elapsed;
                        if (redTimeRemaining <= 0) {
                            redTimeRemaining = 0;
                            handleTimeout('red');
                            return;
                        }
                    } else if (!aiThinking) {
                        blackTimeRemaining -= elapsed;
                        if (blackTimeRemaining <= 0) {
                            blackTimeRemaining = 0;
                            handleTimeout('black');
                            return;
                        }
                    }
                } else {
                    // Online game - only track my own time when it's my turn
                    if (currentPlayer === myColor) {
                        if (myColor === 'red') {
                            redTimeRemaining -= elapsed;
                            if (redTimeRemaining <= 0) {
                                redTimeRemaining = 0;
                                handleTimeout('red');
                                return;
                            }
                        } else {
                            blackTimeRemaining -= elapsed;
                            if (blackTimeRemaining <= 0) {
                                blackTimeRemaining = 0;
                                handleTimeout('black');
                                return;
                            }
                        }
                    }
                }

                // Check move time limit (only for my turn)
                const moveElapsed = now - currentMoveStartTime;
                if (moveElapsed >= moveTimeLimit && currentPlayer === myColor && !aiThinking) {
                    handleMoveTimeout();
                    return;
                }

                updateTimerDisplay();
            }, 100);
        }

        function updateTimerDisplay() {
            const redDisplay = document.getElementById('redTimeDisplay');
            const blackDisplay = document.getElementById('blackTimeDisplay');
            const redTimerEl = document.getElementById('redTimer');
            const blackTimerEl = document.getElementById('blackTimer');
            const redMoveTimerEl = document.getElementById('redMoveTimer');
            const blackMoveTimerEl = document.getElementById('blackMoveTimer');

            if (!redDisplay || !blackDisplay) return;

            redDisplay.textContent = formatTime(redTimeRemaining);
            blackDisplay.textContent = formatTime(blackTimeRemaining);

            // Update timer styling
            redTimerEl.classList.remove('active', 'warning', 'danger');
            blackTimerEl.classList.remove('active', 'warning', 'danger');

            if (!gameOver) {
                if (currentPlayer === 'red') {
                    redTimerEl.classList.add(getTimerClass(redTimeRemaining));
                    // Show move timer
                    const moveRemaining = moveTimeLimit - (Date.now() - currentMoveStartTime);
                    redMoveTimerEl.textContent = `æœ¬æ­¥å‰©ä½™: ${Math.max(0, Math.ceil(moveRemaining / 1000))}ç§’`;
                    blackMoveTimerEl.textContent = '';
                } else {
                    blackTimerEl.classList.add(getTimerClass(blackTimeRemaining));
                    const moveRemaining = moveTimeLimit - (Date.now() - currentMoveStartTime);
                    blackMoveTimerEl.textContent = isAIGame ? '' : `æœ¬æ­¥å‰©ä½™: ${Math.max(0, Math.ceil(moveRemaining / 1000))}ç§’`;
                    redMoveTimerEl.textContent = '';
                }
            } else {
                redMoveTimerEl.textContent = '';
                blackMoveTimerEl.textContent = '';
            }
        }

        function getTimerClass(timeMs) {
            if (timeMs <= 30000) return 'danger';
            if (timeMs <= 60000) return 'warning';
            return 'active';
        }

        function formatTime(ms) {
            const totalSeconds = Math.max(0, Math.floor(ms / 1000));
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function resetMoveTimer() {
            currentMoveStartTime = Date.now();
            const moveCount = currentPlayer === 'red' ? redMoveCount : blackMoveCount;
            moveTimeLimit = getMoveTimeLimit(moveCount);
        }

        function handleTimeout(player) {
            if (gameOver) return;

            gameOver = true;
            clearInterval(gameTimerInterval);

            const winner = player === 'red' ? 'black' : 'red';

            if (isAIGame) {
                if (player === 'red') {
                    statusEl.textContent = 'æ—¶é—´è€—å°½ï¼ä½ è¾“äº†!';
                    playSound('defeat');
                    updateUserStats('loss');
                } else {
                    statusEl.textContent = 'AIè¶…æ—¶ï¼ä½ èµ¢äº†!';
                    playSound('victory');
                    updateUserStats('win');
                }
                document.getElementById('rematchBtn').style.display = 'inline-block';
                updateTimerDisplay();
                drawBoard();
            } else {
                // Online game - update Firebase
                gameRef.update({
                    gameOver: true,
                    winner: winner,
                    timeoutPlayer: player
                });
            }
        }

        function handleMoveTimeout() {
            if (gameOver) return;

            gameOver = true;
            clearInterval(gameTimerInterval);

            if (isAIGame) {
                statusEl.textContent = 'èµ°æ£‹è¶…æ—¶ï¼ä½ è¾“äº†!';
                playSound('defeat');
                updateUserStats('loss');
                document.getElementById('rematchBtn').style.display = 'inline-block';
                updateTimerDisplay();
                drawBoard();
            } else {
                gameRef.update({
                    gameOver: true,
                    winner: myColor === 'red' ? 'black' : 'red',
                    moveTimeoutPlayer: myColor
                });
            }
        }

        function stopGameTimer() {
            if (gameTimerInterval) {
                clearInterval(gameTimerInterval);
                gameTimerInterval = null;
            }
        }

        // ============================================
        // AI GAME LOGIC
        // ============================================
        const pieceValues = {
            1: 10000, 2: 20, 3: 20, 4: 40, 5: 90, 6: 45, 7: 10,
            11: 10000, 12: 20, 13: 20, 14: 40, 15: 90, 16: 45, 17: 10
        };

        function startAIGame() {
            if (!currentUser) {
                alert('è¯·å…ˆç™»å½•');
                return;
            }

            isAIGame = true;
            aiDepth = parseInt(document.getElementById('aiDifficulty').value);
            myColor = 'red';
            gameStarted = true;
            gameOver = false;
            currentPlayer = 'red';
            opponentJoined = true; // AI is always ready

            document.getElementById('lobby').style.display = 'none';
            document.getElementById('gameArea').style.display = 'block';

            // Set up player info for AI game
            document.getElementById('redPlayerInfo').innerHTML = `
                <img src="${userProfile.photoURL || 'https://via.placeholder.com/24'}" alt="">
                <span>${userProfile.displayName || 'ä½ '}</span>
            `;
            document.getElementById('blackPlayerInfo').innerHTML = `
                <img src="https://ui-avatars.com/api/?name=AI&background=333&color=fff&size=24" alt="">
                <span>AI (${aiDepth === 2 ? 'ç®€å•' : aiDepth === 3 ? 'ä¸­ç­‰' : 'å›°éš¾'})</span>
            `;

            initBoard();
            resizeCanvas();
            updateAIGameUI();
            drawBoard();

            // Initialize timers for AI game (10 minutes default)
            initializeTimers(selectedAITimeControl);
        }

        function updateAIGameUI() {
            const redInfo = document.getElementById('redPlayerInfo');
            const blackInfo = document.getElementById('blackPlayerInfo');

            redInfo.classList.toggle('active', currentPlayer === 'red' && !gameOver);
            blackInfo.classList.toggle('active', currentPlayer === 'black' && !gameOver);

            if (gameOver) {
                // Game over handled elsewhere
            } else if (aiThinking) {
                statusEl.textContent = 'AIæ€è€ƒä¸­...';
            } else if (currentPlayer === 'red') {
                statusEl.textContent = 'è½®åˆ°ä½ èµ°æ£‹';
            } else {
                statusEl.textContent = 'ç­‰å¾…AI...';
            }
        }

        function evaluateBoard(boardState) {
            let score = 0;
            const positionBonus = [
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 1, 3, 5, 5, 5, 3, 1, 1],
                [2, 4, 6, 8, 10, 8, 6, 4, 2],
                [3, 6, 9, 12, 15, 12, 9, 6, 3],
                [4, 8, 12, 16, 20, 16, 12, 8, 4],
                [5, 10, 15, 20, 25, 20, 15, 10, 5],
                [6, 12, 18, 24, 30, 24, 18, 12, 6],
                [0, 0, 0, 0, 0, 0, 0, 0, 0]
            ];

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = boardState[r][c];
                    if (piece === EMPTY) continue;

                    let value = pieceValues[piece] || 0;

                    if (piece === 7) value += positionBonus[r][c];
                    else if (piece === 17) value += positionBonus[9 - r][c];

                    const moves = getValidMoves(r, c, boardState);
                    value += moves.length * 0.5;

                    score += isRed(piece) ? -value : value;
                }
            }
            return score;
        }

        function getAllMovesForPlayer(isRedPlayer, boardState) {
            const moves = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = boardState[r][c];
                    if (piece !== EMPTY && (isRedPlayer ? isRed(piece) : isBlack(piece))) {
                        const pieceMoves = getLegalMoves(r, c, boardState);
                        pieceMoves.forEach(m => {
                            moves.push({ fromRow: r, fromCol: c, toRow: m.row, toCol: m.col });
                        });
                    }
                }
            }
            return moves;
        }

        function minimax(boardState, depth, alpha, beta, isMaximizing) {
            if (depth === 0) {
                return { score: evaluateBoard(boardState) };
            }

            const moves = getAllMovesForPlayer(!isMaximizing, boardState);

            if (moves.length === 0) {
                if (isInCheck(!isMaximizing, boardState)) {
                    return { score: isMaximizing ? -99999 : 99999 };
                }
                return { score: 0 };
            }

            let bestMove = null;

            if (isMaximizing) {
                let maxScore = -Infinity;
                for (const move of moves) {
                    const testBoard = boardState.map(r => [...r]);
                    makeMoveOnBoard(move.fromRow, move.fromCol, move.toRow, move.toCol, testBoard);
                    const result = minimax(testBoard, depth - 1, alpha, beta, false);

                    if (result.score > maxScore) {
                        maxScore = result.score;
                        bestMove = move;
                    }
                    alpha = Math.max(alpha, result.score);
                    if (beta <= alpha) break;
                }
                return { score: maxScore, move: bestMove };
            } else {
                let minScore = Infinity;
                for (const move of moves) {
                    const testBoard = boardState.map(r => [...r]);
                    makeMoveOnBoard(move.fromRow, move.fromCol, move.toRow, move.toCol, testBoard);
                    const result = minimax(testBoard, depth - 1, alpha, beta, true);

                    if (result.score < minScore) {
                        minScore = result.score;
                        bestMove = move;
                    }
                    beta = Math.min(beta, result.score);
                    if (beta <= alpha) break;
                }
                return { score: minScore, move: bestMove };
            }
        }

        function makeAIMove() {
            if (gameOver || currentPlayer !== 'black' || !isAIGame) return;

            aiThinking = true;
            updateAIGameUI();
            drawBoard();

            setTimeout(() => {
                const boardCopy = board.map(row => [...row]);
                const result = minimax(boardCopy, aiDepth, -Infinity, Infinity, true);

                if (result.move) {
                    // Save state before AI move for undo
                    saveToHistory();

                    const captured = board[result.move.toRow][result.move.toCol];
                    makeMoveOnBoard(result.move.fromRow, result.move.fromCol, result.move.toRow, result.move.toCol, board);

                    lastMove = {
                        fromRow: result.move.fromRow,
                        fromCol: result.move.fromCol,
                        toRow: result.move.toRow,
                        toCol: result.move.toCol
                    };

                    if (captured !== EMPTY) {
                        playSound('capture');
                    } else {
                        playSound('move');
                    }

                    if (captured === R_GENERAL) {
                        gameOver = true;
                        statusEl.textContent = 'ä½ è¾“äº†!';
                        playSound('defeat');
                        updateUserStats('loss');
                        document.getElementById('rematchBtn').style.display = 'inline-block';
                    } else if (isInCheck(true, board)) {
                        if (!hasLegalMoves(true, board)) {
                            gameOver = true;
                            statusEl.textContent = 'å°†æ­»ï¼ä½ è¾“äº†!';
                            playSound('defeat');
                            updateUserStats('loss');
                            document.getElementById('rematchBtn').style.display = 'inline-block';
                        } else {
                            currentPlayer = 'red';
                            playSound('check');
                        }
                    } else {
                        currentPlayer = 'red';
                    }
                } else {
                    gameOver = true;
                    statusEl.textContent = 'ä½ èµ¢äº†!';
                    playSound('victory');
                    updateUserStats('win');
                    document.getElementById('rematchBtn').style.display = 'inline-block';
                }

                aiThinking = false;

                // Update timer after AI move
                if (!gameOver) {
                    blackMoveCount++;
                    resetMoveTimer();
                }

                updateAIGameUI();
                updateTimerDisplay();
                drawBoard();
            }, 100);
        }

        // ============================================
        // ONLINE GAME LOGIC
        // ============================================
        function generateRoomId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function createGame() {
            if (!currentUser) {
                alert('è¯·å…ˆç™»å½•');
                return;
            }

            roomId = generateRoomId();
            myColor = 'red';
            isAIGame = false;

            gameRef = db.ref('games/' + roomId);

            const totalTimeMs = selectedTimeControl * 60 * 1000;
            const initialState = {
                board: getInitialBoard(),
                currentPlayer: 'red',
                redPlayer: {
                    odule: currentUser.uid,
                    displayName: userProfile.displayName,
                    photoURL: userProfile.photoURL
                },
                blackPlayer: null,
                lastMove: null,
                gameOver: false,
                winner: null,
                rematchRequest: null,
                statsUpdated: false,
                created: Date.now(),
                // Timer data
                timeControl: selectedTimeControl,
                redTimeRemaining: totalTimeMs,
                blackTimeRemaining: totalTimeMs,
                redMoveCount: 0,
                blackMoveCount: 0,
                lastMoveTime: null,
                turnStartTime: null
            };

            gameRef.set(initialState).then(() => {
                // Go directly to game area
                gameStarted = true;
                document.getElementById('lobby').style.display = 'none';
                document.getElementById('gameArea').style.display = 'block';

                // Show share link section
                const shareUrl = window.location.origin + window.location.pathname + '?room=' + roomId;
                document.getElementById('gameShareLink').href = shareUrl;
                document.getElementById('gameShareLink').textContent = shareUrl;
                document.getElementById('gameRoomId').textContent = roomId;
                document.getElementById('shareSection').style.display = 'block';

                // Set up player info (red player is current user, black is waiting)
                document.getElementById('redPlayerInfo').innerHTML = `
                    <img src="${userProfile.photoURL || 'https://via.placeholder.com/24'}" alt="">
                    <span>${userProfile.displayName || 'çº¢æ–¹'}</span>
                `;
                document.getElementById('blackPlayerInfo').innerHTML = `
                    <img src="https://via.placeholder.com/24" alt="">
                    <span>ç­‰å¾…ä¸­...</span>
                `;

                initBoard();
                setupGameListeners();
                resizeCanvas();
                drawBoard();
            });
        }

        function joinGame() {
            if (!currentUser) {
                alert('è¯·å…ˆç™»å½•');
                return;
            }

            roomId = document.getElementById('joinRoomId').value.trim().toUpperCase();
            if (!roomId) {
                alert('è¯·è¾“å…¥æˆ¿é—´å·');
                return;
            }

            gameRef = db.ref('games/' + roomId);

            gameRef.once('value').then((snapshot) => {
                const game = snapshot.val();
                if (!game) {
                    alert('æˆ¿é—´ä¸å­˜åœ¨');
                    return;
                }

                // Check if user is the red player (creator) - resume as red
                if (game.redPlayer && game.redPlayer.odule === currentUser.uid) {
                    myColor = 'red';
                    isAIGame = false;
                    if (game.blackPlayer) {
                        // Game already has opponent, resume game
                        opponentProfile = game.blackPlayer;
                    }
                    // Show game area (with share link if waiting for opponent)
                    const shareUrl = window.location.origin + window.location.pathname + '?room=' + roomId;
                    document.getElementById('gameShareLink').href = shareUrl;
                    document.getElementById('gameShareLink').textContent = shareUrl;
                    document.getElementById('gameRoomId').textContent = roomId;
                    startGame();
                    return;
                }

                // Check if user is the black player - resume as black
                if (game.blackPlayer && game.blackPlayer.odule === currentUser.uid) {
                    myColor = 'black';
                    isAIGame = false;
                    opponentProfile = game.redPlayer;
                    startGame();
                    return;
                }

                // New player trying to join
                if (game.blackPlayer) {
                    alert('æˆ¿é—´å·²æ»¡');
                    return;
                }

                myColor = 'black';
                opponentProfile = game.redPlayer;

                gameRef.update({
                    blackPlayer: {
                        odule: currentUser.uid,
                        displayName: userProfile.displayName,
                        photoURL: userProfile.photoURL
                    }
                }).then(() => {
                    startGame();
                });
            });
        }

        function startGame() {
            gameStarted = true;
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('gameArea').style.display = 'block';

            initBoard();
            setupGameListeners();
            resizeCanvas();
            drawBoard();
        }

        function updatePlayerInfoUI(game) {
            const redInfo = document.getElementById('redPlayerInfo');
            const blackInfo = document.getElementById('blackPlayerInfo');

            if (game.redPlayer) {
                redInfo.innerHTML = `
                    <img src="${game.redPlayer.photoURL || 'https://via.placeholder.com/24'}" alt="">
                    <span>${game.redPlayer.displayName || 'çº¢æ–¹'}</span>
                `;
            } else {
                redInfo.innerHTML = `
                    <img src="https://via.placeholder.com/24" alt="">
                    <span>ç­‰å¾…ä¸­...</span>
                `;
            }

            if (game.blackPlayer) {
                blackInfo.innerHTML = `
                    <img src="${game.blackPlayer.photoURL || 'https://via.placeholder.com/24'}" alt="">
                    <span>${game.blackPlayer.displayName || 'é»‘æ–¹'}</span>
                `;
            } else {
                blackInfo.innerHTML = `
                    <img src="https://via.placeholder.com/24" alt="">
                    <span>ç­‰å¾…ä¸­...</span>
                `;
            }

            // Highlight current player only when both players present
            const bothPlayersPresent = game.redPlayer && game.blackPlayer;
            redInfo.classList.toggle('active', bothPlayersPresent && game.currentPlayer === 'red' && !game.gameOver);
            blackInfo.classList.toggle('active', bothPlayersPresent && game.currentPlayer === 'black' && !game.gameOver);
        }

        function setupGameListeners() {
            let timerInitialized = false;

            gameRef.on('value', async (snapshot) => {
                const game = snapshot.val();
                if (!game) {
                    alert('æ¸¸æˆå·²ç»“æŸ');
                    leaveGame();
                    return;
                }

                // Update board state
                board = game.board;
                currentPlayer = game.currentPlayer;
                lastMove = game.lastMove;
                gameOver = game.gameOver;

                // Sync timer data from Firebase
                const bothPlayersPresent = game.redPlayer && game.blackPlayer;
                opponentJoined = bothPlayersPresent;

                if (game.timeControl !== undefined) {
                    redTimeRemaining = game.redTimeRemaining || game.timeControl * 60 * 1000;
                    blackTimeRemaining = game.blackTimeRemaining || game.timeControl * 60 * 1000;
                    redMoveCount = game.redMoveCount || 0;
                    blackMoveCount = game.blackMoveCount || 0;

                    // Initialize timer on first load - ONLY when both players are present
                    if (!timerInitialized && !gameOver && bothPlayersPresent) {
                        timerInitialized = true;
                        selectedTimeControl = game.timeControl;
                        currentMoveStartTime = game.turnStartTime || Date.now();
                        moveTimeLimit = getMoveTimeLimit(currentPlayer === 'red' ? redMoveCount : blackMoveCount);
                        lastTimerUpdate = Date.now();

                        // Set turnStartTime if not set (game just started)
                        if (!game.turnStartTime) {
                            gameRef.update({ turnStartTime: Date.now() });
                        }

                        startGameTimer();
                    }

                    // Reset move timer when opponent makes a move
                    if (game.lastMoveBy && game.lastMoveBy !== myColor && game.turnStartTime) {
                        currentMoveStartTime = game.turnStartTime;
                        moveTimeLimit = getMoveTimeLimit(currentPlayer === 'red' ? redMoveCount : blackMoveCount);
                    }

                    // Only update timer display when both players present
                    if (bothPlayersPresent) {
                        updateTimerDisplay();
                    }
                }

                updatePlayerInfoUI(game);

                if (game.lastMove && game.lastMoveBy !== myColor) {
                    // Opponent made a move - play sound
                    if (game.lastMoveWasCapture) {
                        playSound('capture');
                    } else {
                        playSound('move');
                    }
                    if (game.inCheck && currentPlayer === myColor) {
                        playSound('check');
                    }
                }

                // Update status and stats
                if (gameOver) {
                    stopGameTimer();
                    document.getElementById('rematchBtn').style.display = 'inline-block';

                    // Show timeout message if applicable
                    if (game.timeoutPlayer) {
                        if (game.timeoutPlayer === myColor) {
                            statusEl.textContent = 'æ—¶é—´è€—å°½ï¼ä½ è¾“äº†!';
                        } else {
                            statusEl.textContent = 'å¯¹æ‰‹æ—¶é—´è€—å°½ï¼ä½ èµ¢äº†!';
                        }
                    } else if (game.moveTimeoutPlayer) {
                        if (game.moveTimeoutPlayer === myColor) {
                            statusEl.textContent = 'èµ°æ£‹è¶…æ—¶ï¼ä½ è¾“äº†!';
                        } else {
                            statusEl.textContent = 'å¯¹æ‰‹èµ°æ£‹è¶…æ—¶ï¼ä½ èµ¢äº†!';
                        }
                    }

                    // Update stats only once
                    if (!game.statsUpdated) {
                        if (game.winner === myColor) {
                            if (!game.timeoutPlayer && !game.moveTimeoutPlayer) {
                                statusEl.textContent = 'ä½ èµ¢äº†!';
                            }
                            playSound('victory');
                            await updateUserStats('win');
                        } else if (game.winner) {
                            if (!game.timeoutPlayer && !game.moveTimeoutPlayer) {
                                statusEl.textContent = 'ä½ è¾“äº†!';
                            }
                            playSound('defeat');
                            await updateUserStats('loss');
                        } else {
                            statusEl.textContent = 'å’Œæ£‹!';
                            await updateUserStats('draw');
                        }

                        // Mark stats as updated (only one player should do this)
                        if (myColor === 'red') {
                            gameRef.update({ statsUpdated: true });
                        }
                    } else {
                        if (!game.timeoutPlayer && !game.moveTimeoutPlayer) {
                            if (game.winner === myColor) {
                                statusEl.textContent = 'ä½ èµ¢äº†!';
                            } else if (game.winner) {
                                statusEl.textContent = 'ä½ è¾“äº†!';
                            } else {
                                statusEl.textContent = 'å’Œæ£‹!';
                            }
                        }
                    }
                } else if (!bothPlayersPresent) {
                    // Waiting for opponent to join
                    statusEl.textContent = 'ç­‰å¾…å¯¹æ‰‹åŠ å…¥...';
                    document.getElementById('gameTimers').style.opacity = '0.3';
                    document.getElementById('shareSection').style.display = 'block';
                } else if (currentPlayer === myColor) {
                    statusEl.textContent = 'è½®åˆ°ä½ èµ°æ£‹';
                    document.getElementById('gameTimers').style.opacity = '1';
                    document.getElementById('shareSection').style.display = 'none';
                } else {
                    statusEl.textContent = 'ç­‰å¾…å¯¹æ‰‹...';
                    document.getElementById('gameTimers').style.opacity = '1';
                    document.getElementById('shareSection').style.display = 'none';
                }

                // Handle rematch request
                if (game.rematchRequest && game.rematchRequest !== myColor) {
                    if (confirm('å¯¹æ‰‹è¯·æ±‚å†æ¥ä¸€å±€ï¼Œæ˜¯å¦åŒæ„ï¼Ÿ')) {
                        const totalTimeMs = (game.timeControl || 10) * 60 * 1000;
                        gameRef.update({
                            board: getInitialBoard(),
                            currentPlayer: 'red',
                            lastMove: null,
                            gameOver: false,
                            winner: null,
                            rematchRequest: null,
                            inCheck: false,
                            statsUpdated: false,
                            // Reset timer data
                            redTimeRemaining: totalTimeMs,
                            blackTimeRemaining: totalTimeMs,
                            redMoveCount: 0,
                            blackMoveCount: 0,
                            turnStartTime: Date.now(),
                            timeoutPlayer: null,
                            moveTimeoutPlayer: null,
                            previousBoard: null,
                            previousState: null,
                            undoRequest: null
                        });
                        document.getElementById('rematchBtn').style.display = 'none';
                        timerInitialized = false;
                    }
                }

                // Handle undo request
                if (game.undoRequest && game.undoRequest !== myColor && game.previousState) {
                    if (confirm('å¯¹æ‰‹è¯·æ±‚æ‚”æ£‹ï¼Œæ˜¯å¦åŒæ„ï¼Ÿ')) {
                        const prevState = game.previousState;
                        gameRef.update({
                            board: prevState.board,
                            currentPlayer: prevState.currentPlayer,
                            lastMove: prevState.lastMove,
                            redMoveCount: prevState.redMoveCount,
                            blackMoveCount: prevState.blackMoveCount,
                            redTimeRemaining: prevState.redTimeRemaining,
                            blackTimeRemaining: prevState.blackTimeRemaining,
                            turnStartTime: Date.now(),
                            undoRequest: null,
                            previousState: null
                        });
                    } else {
                        // Declined - clear the request
                        gameRef.update({ undoRequest: null });
                    }
                }

                drawBoard();
            });

            // Handle disconnection
            const playerPath = myColor === 'red' ? 'redPlayer' : 'blackPlayer';
            gameRef.child(playerPath).onDisconnect().set(null);
        }

        function leaveGame() {
            // Stop game timer
            stopGameTimer();

            if (!isAIGame && gameRef) {
                gameRef.off();
                if (myColor === 'red') {
                    gameRef.remove();
                } else {
                    gameRef.update({ blackPlayer: null });
                }
            }
            gameStarted = false;
            gameOver = false;
            isAIGame = false;
            aiThinking = false;
            opponentJoined = false;
            selectedPiece = null;
            validMoves = [];
            lastMove = null;

            // Reset timer variables
            redTimeRemaining = 0;
            blackTimeRemaining = 0;
            redMoveCount = 0;
            blackMoveCount = 0;

            document.getElementById('rematchBtn').style.display = 'none';
            document.getElementById('shareSection').style.display = 'none';
            document.getElementById('gameArea').style.display = 'none';
            document.getElementById('lobby').style.display = 'block';

            // Show appropriate section based on selected mode
            selectMode(selectedGameMode);

            // Clear URL params
            window.history.replaceState({}, document.title, window.location.pathname);
        }

        function requestRematch() {
            if (isAIGame) {
                // AI game - just restart
                gameOver = false;
                currentPlayer = 'red';
                selectedPiece = null;
                validMoves = [];
                lastMove = null;
                moveHistory = []; // Clear move history
                initBoard();
                document.getElementById('rematchBtn').style.display = 'none';

                // Reset timers for new game
                initializeTimers(selectedAITimeControl);

                updateAIGameUI();
                drawBoard();
            } else {
                gameRef.update({ rematchRequest: myColor });
                alert('å·²å‘é€å†æ¥ä¸€å±€è¯·æ±‚ï¼Œç­‰å¾…å¯¹æ‰‹ç¡®è®¤...');
            }
        }

        // Move history for undo feature
        let moveHistory = [];

        function saveToHistory() {
            moveHistory.push({
                board: board.map(row => [...row]),
                currentPlayer: currentPlayer,
                lastMove: lastMove ? { ...lastMove } : null,
                redMoveCount: redMoveCount,
                blackMoveCount: blackMoveCount,
                redTimeRemaining: redTimeRemaining,
                blackTimeRemaining: blackTimeRemaining
            });
            // Keep only last 10 moves to save memory
            if (moveHistory.length > 10) {
                moveHistory.shift();
            }
        }

        function requestUndo() {
            if (gameOver) {
                alert('æ¸¸æˆå·²ç»“æŸï¼Œæ— æ³•æ‚”æ£‹');
                return;
            }

            if (isAIGame) {
                // AI game - undo immediately (undo both player and AI moves)
                if (moveHistory.length < 2) {
                    alert('æ²¡æœ‰å¯ä»¥æ’¤é”€çš„æ­¥éª¤');
                    return;
                }

                // Undo AI's move and player's move
                moveHistory.pop(); // Remove AI's last move
                const prevState = moveHistory.pop(); // Get state before player's move

                board = prevState.board;
                currentPlayer = prevState.currentPlayer;
                lastMove = prevState.lastMove;
                redMoveCount = prevState.redMoveCount;
                blackMoveCount = prevState.blackMoveCount;
                redTimeRemaining = prevState.redTimeRemaining;
                blackTimeRemaining = prevState.blackTimeRemaining;

                selectedPiece = null;
                validMoves = [];

                updateTimerDisplay();
                updateAIGameUI();
                drawBoard();
                playSound('move');
            } else {
                // Online game - request undo from opponent
                // Can only request undo when it's opponent's turn (after you made a move)
                if (currentPlayer === myColor) {
                    alert('åªèƒ½åœ¨å¯¹æ‰‹å›åˆæ—¶è¯·æ±‚æ‚”æ£‹');
                    return;
                }
                gameRef.update({ undoRequest: myColor });
                alert('å·²å‘é€æ‚”æ£‹è¯·æ±‚ï¼Œç­‰å¾…å¯¹æ‰‹ç¡®è®¤...');
            }
        }

        function copyLink() {
            const link = document.getElementById('shareLink').href;
            navigator.clipboard.writeText(link).then(() => {
                alert('é“¾æ¥å·²å¤åˆ¶!');
            });
        }

        function copyGameLink() {
            const link = document.getElementById('gameShareLink').href;
            navigator.clipboard.writeText(link).then(() => {
                alert('é“¾æ¥å·²å¤åˆ¶!');
            });
        }

        // ============================================
        // GAME RENDERING & LOGIC
        // ============================================

        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');

        // Sound system
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let soundEnabled = true;

        function playSound(type) {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            switch (type) {
                case 'select':
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.1);
                    break;
                case 'move':
                    oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.1);
                    oscillator.type = 'triangle';
                    gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.15);
                    break;
                case 'capture':
                    oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.2);
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.25);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.25);
                    break;
                case 'check':
                    oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime + 0.1);
                    oscillator.frequency.setValueAtTime(600, audioCtx.currentTime + 0.2);
                    oscillator.type = 'square';
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.35);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.35);
                    break;
                case 'victory':
                    [523, 659, 784, 1047].forEach((freq, i) => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        osc.frequency.setValueAtTime(freq, audioCtx.currentTime + i * 0.15);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0.3, audioCtx.currentTime + i * 0.15);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.15 + 0.3);
                        osc.start(audioCtx.currentTime + i * 0.15);
                        osc.stop(audioCtx.currentTime + i * 0.15 + 0.3);
                    });
                    return;
                case 'defeat':
                    oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.5);
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.6);
                    break;
            }
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundBtn').textContent = soundEnabled ? 'å…³é—­éŸ³æ•ˆ' : 'å¼€å¯éŸ³æ•ˆ';
        }

        // Base dimensions (for scaling)
        const BASE_WIDTH = 520;
        const BASE_HEIGHT = 580;
        const BASE_CELL_SIZE = 57;
        const BASE_MARGIN = 30;
        const COLS = 9;
        const ROWS = 10;

        // Dynamic scaling variables
        let scale = 1;
        let CELL_SIZE = BASE_CELL_SIZE;
        let MARGIN = BASE_MARGIN;

        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth - 30, 520);
            scale = maxWidth / BASE_WIDTH;

            canvas.style.width = (BASE_WIDTH * scale) + 'px';
            canvas.style.height = (BASE_HEIGHT * scale) + 'px';

            canvas.width = BASE_WIDTH;
            canvas.height = BASE_HEIGHT;

            CELL_SIZE = BASE_CELL_SIZE;
            MARGIN = BASE_MARGIN;

            if (gameStarted) {
                drawBoard();
            }
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        const EMPTY = 0;
        const R_GENERAL = 1, R_ADVISOR = 2, R_ELEPHANT = 3, R_HORSE = 4, R_CHARIOT = 5, R_CANNON = 6, R_SOLDIER = 7;
        const B_GENERAL = 11, B_ADVISOR = 12, B_ELEPHANT = 13, B_HORSE = 14, B_CHARIOT = 15, B_CANNON = 16, B_SOLDIER = 17;

        const pieceNames = {
            [R_GENERAL]: 'å¸…', [R_ADVISOR]: 'ä»•', [R_ELEPHANT]: 'ç›¸', [R_HORSE]: 'é¦¬',
            [R_CHARIOT]: 'è»Š', [R_CANNON]: 'ç‚®', [R_SOLDIER]: 'å…µ',
            [B_GENERAL]: 'å°†', [B_ADVISOR]: 'å£«', [B_ELEPHANT]: 'è±¡', [B_HORSE]: 'é©¬',
            [B_CHARIOT]: 'è½¦', [B_CANNON]: 'ç ²', [B_SOLDIER]: 'å’'
        };

        let board = [];
        let selectedPiece = null;
        let validMoves = [];
        let currentPlayer = 'red';
        let gameOver = false;
        let lastMove = null;

        function isRed(piece) { return piece >= 1 && piece <= 7; }
        function isBlack(piece) { return piece >= 11 && piece <= 17; }
        function isEnemy(piece1, piece2) {
            return (isRed(piece1) && isBlack(piece2)) || (isBlack(piece1) && isRed(piece2));
        }
        function isMyPiece(piece) {
            return myColor === 'red' ? isRed(piece) : isBlack(piece);
        }

        function getInitialBoard() {
            const b = Array(ROWS).fill(null).map(() => Array(COLS).fill(EMPTY));
            b[0][0] = B_CHARIOT; b[0][8] = B_CHARIOT;
            b[0][1] = B_HORSE; b[0][7] = B_HORSE;
            b[0][2] = B_ELEPHANT; b[0][6] = B_ELEPHANT;
            b[0][3] = B_ADVISOR; b[0][5] = B_ADVISOR;
            b[0][4] = B_GENERAL;
            b[2][1] = B_CANNON; b[2][7] = B_CANNON;
            b[3][0] = B_SOLDIER; b[3][2] = B_SOLDIER; b[3][4] = B_SOLDIER;
            b[3][6] = B_SOLDIER; b[3][8] = B_SOLDIER;
            b[9][0] = R_CHARIOT; b[9][8] = R_CHARIOT;
            b[9][1] = R_HORSE; b[9][7] = R_HORSE;
            b[9][2] = R_ELEPHANT; b[9][6] = R_ELEPHANT;
            b[9][3] = R_ADVISOR; b[9][5] = R_ADVISOR;
            b[9][4] = R_GENERAL;
            b[7][1] = R_CANNON; b[7][7] = R_CANNON;
            b[6][0] = R_SOLDIER; b[6][2] = R_SOLDIER; b[6][4] = R_SOLDIER;
            b[6][6] = R_SOLDIER; b[6][8] = R_SOLDIER;
            return b;
        }

        function initBoard() {
            board = getInitialBoard();
        }

        function drawBoard() {
            ctx.fillStyle = '#e8c373';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#5d4037';
            ctx.lineWidth = 1;

            for (let i = 0; i < ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(MARGIN, MARGIN + i * CELL_SIZE);
                ctx.lineTo(MARGIN + 8 * CELL_SIZE, MARGIN + i * CELL_SIZE);
                ctx.stroke();
            }

            for (let j = 0; j < COLS; j++) {
                ctx.beginPath();
                ctx.moveTo(MARGIN + j * CELL_SIZE, MARGIN);
                ctx.lineTo(MARGIN + j * CELL_SIZE, MARGIN + 4 * CELL_SIZE);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(MARGIN + j * CELL_SIZE, MARGIN + 5 * CELL_SIZE);
                ctx.lineTo(MARGIN + j * CELL_SIZE, MARGIN + 9 * CELL_SIZE);
                ctx.stroke();
            }

            ctx.beginPath();
            ctx.moveTo(MARGIN, MARGIN + 4 * CELL_SIZE);
            ctx.lineTo(MARGIN, MARGIN + 5 * CELL_SIZE);
            ctx.moveTo(MARGIN + 8 * CELL_SIZE, MARGIN + 4 * CELL_SIZE);
            ctx.lineTo(MARGIN + 8 * CELL_SIZE, MARGIN + 5 * CELL_SIZE);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(MARGIN + 3 * CELL_SIZE, MARGIN);
            ctx.lineTo(MARGIN + 5 * CELL_SIZE, MARGIN + 2 * CELL_SIZE);
            ctx.moveTo(MARGIN + 5 * CELL_SIZE, MARGIN);
            ctx.lineTo(MARGIN + 3 * CELL_SIZE, MARGIN + 2 * CELL_SIZE);
            ctx.moveTo(MARGIN + 3 * CELL_SIZE, MARGIN + 7 * CELL_SIZE);
            ctx.lineTo(MARGIN + 5 * CELL_SIZE, MARGIN + 9 * CELL_SIZE);
            ctx.moveTo(MARGIN + 5 * CELL_SIZE, MARGIN + 7 * CELL_SIZE);
            ctx.lineTo(MARGIN + 3 * CELL_SIZE, MARGIN + 9 * CELL_SIZE);
            ctx.stroke();

            ctx.font = '24px serif';
            ctx.fillStyle = '#5d4037';
            ctx.textAlign = 'center';
            ctx.fillText('æ¥š æ²³', MARGIN + 1.5 * CELL_SIZE, MARGIN + 4.6 * CELL_SIZE);
            ctx.fillText('æ±‰ ç•Œ', MARGIN + 6.5 * CELL_SIZE, MARGIN + 4.6 * CELL_SIZE);

            if (lastMove) {
                const fromX = MARGIN + lastMove.fromCol * CELL_SIZE;
                const fromY = MARGIN + lastMove.fromRow * CELL_SIZE;
                ctx.fillStyle = 'rgba(255, 215, 0, 0.4)';
                ctx.fillRect(fromX - 28, fromY - 28, 56, 56);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.strokeRect(fromX - 28, fromY - 28, 56, 56);

                const toX = MARGIN + lastMove.toCol * CELL_SIZE;
                const toY = MARGIN + lastMove.toRow * CELL_SIZE;
                ctx.fillStyle = 'rgba(255, 140, 0, 0.4)';
                ctx.fillRect(toX - 28, toY - 28, 56, 56);
                ctx.strokeStyle = '#ff8c00';
                ctx.lineWidth = 2;
                ctx.strokeRect(toX - 28, toY - 28, 56, 56);
            }

            validMoves.forEach(move => {
                const x = MARGIN + move.col * CELL_SIZE;
                const y = MARGIN + move.row * CELL_SIZE;
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.fillStyle = board[move.row][move.col] !== EMPTY ? 'rgba(255,0,0,0.5)' : 'rgba(0,128,0,0.5)';
                ctx.fill();
            });

            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const piece = board[row][col];
                    if (piece !== EMPTY) {
                        drawPiece(col, row, piece, selectedPiece && selectedPiece.row === row && selectedPiece.col === col);
                    }
                }
            }
        }

        function drawPiece(col, row, piece, selected) {
            const x = MARGIN + col * CELL_SIZE;
            const y = MARGIN + row * CELL_SIZE;
            const radius = 25;

            ctx.beginPath();
            ctx.arc(x + 2, y + 2, radius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fill();

            const gradient = ctx.createRadialGradient(x - 5, y - 5, 0, x, y, radius);
            gradient.addColorStop(0, '#fff8dc');
            gradient.addColorStop(1, '#deb887');
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            ctx.strokeStyle = selected ? '#00ff00' : '#8b4513';
            ctx.lineWidth = selected ? 3 : 2;
            ctx.stroke();

            ctx.font = 'bold 28px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = isRed(piece) ? '#c41e3a' : '#1a1a1a';
            ctx.fillText(pieceNames[piece], x, y + 2);
        }

        function getValidMoves(row, col, boardState = board) {
            const piece = boardState[row][col];
            const moves = [];

            const addMove = (r, c) => {
                if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                    const target = boardState[r][c];
                    if (target === EMPTY || isEnemy(piece, target)) {
                        moves.push({ row: r, col: c });
                    }
                }
            };

            const canMoveTo = (r, c) => {
                if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return false;
                const target = boardState[r][c];
                return target === EMPTY || isEnemy(piece, target);
            };

            const pieceType = piece <= 7 ? piece : piece - 10;
            const isRedPiece = isRed(piece);

            switch (pieceType) {
                case 1:
                    const gMinRow = isRedPiece ? 7 : 0;
                    const gMaxRow = isRedPiece ? 9 : 2;
                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                        const nr = row + dr, nc = col + dc;
                        if (nr >= gMinRow && nr <= gMaxRow && nc >= 3 && nc <= 5 && canMoveTo(nr, nc)) {
                            moves.push({ row: nr, col: nc });
                        }
                    });
                    const enemyGeneral = isRedPiece ? B_GENERAL : R_GENERAL;
                    let blocked = false;
                    const dir = isRedPiece ? -1 : 1;
                    for (let r = row + dir; r >= 0 && r < ROWS; r += dir) {
                        if (boardState[r][col] === enemyGeneral && !blocked) {
                            moves.push({ row: r, col: col });
                            break;
                        }
                        if (boardState[r][col] !== EMPTY) blocked = true;
                    }
                    break;
                case 2:
                    const aMinRow = isRedPiece ? 7 : 0;
                    const aMaxRow = isRedPiece ? 9 : 2;
                    [[1, 1], [1, -1], [-1, 1], [-1, -1]].forEach(([dr, dc]) => {
                        const nr = row + dr, nc = col + dc;
                        if (nr >= aMinRow && nr <= aMaxRow && nc >= 3 && nc <= 5 && canMoveTo(nr, nc)) {
                            moves.push({ row: nr, col: nc });
                        }
                    });
                    break;
                case 3:
                    const eMinRow = isRedPiece ? 5 : 0;
                    const eMaxRow = isRedPiece ? 9 : 4;
                    [[2, 2, 1, 1], [2, -2, 1, -1], [-2, 2, -1, 1], [-2, -2, -1, -1]].forEach(([dr, dc, br, bc]) => {
                        const nr = row + dr, nc = col + dc;
                        const blockR = row + br, blockC = col + bc;
                        if (nr >= eMinRow && nr <= eMaxRow && nc >= 0 && nc < COLS &&
                            boardState[blockR][blockC] === EMPTY && canMoveTo(nr, nc)) {
                            moves.push({ row: nr, col: nc });
                        }
                    });
                    break;
                case 4:
                    [[2, 1, 1, 0], [2, -1, 1, 0], [-2, 1, -1, 0], [-2, -1, -1, 0],
                     [1, 2, 0, 1], [1, -2, 0, -1], [-1, 2, 0, 1], [-1, -2, 0, -1]
                    ].forEach(([dr, dc, br, bc]) => {
                        const nr = row + dr, nc = col + dc;
                        const blockR = row + br, blockC = col + bc;
                        if (blockR >= 0 && blockR < ROWS && blockC >= 0 && blockC < COLS &&
                            boardState[blockR][blockC] === EMPTY && canMoveTo(nr, nc)) {
                            moves.push({ row: nr, col: nc });
                        }
                    });
                    break;
                case 5:
                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                        for (let i = 1; i < 10; i++) {
                            const nr = row + dr * i, nc = col + dc * i;
                            if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) break;
                            if (boardState[nr][nc] === EMPTY) {
                                moves.push({ row: nr, col: nc });
                            } else {
                                if (isEnemy(piece, boardState[nr][nc])) moves.push({ row: nr, col: nc });
                                break;
                            }
                        }
                    });
                    break;
                case 6:
                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                        let jumped = false;
                        for (let i = 1; i < 10; i++) {
                            const nr = row + dr * i, nc = col + dc * i;
                            if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) break;
                            if (!jumped) {
                                if (boardState[nr][nc] === EMPTY) moves.push({ row: nr, col: nc });
                                else jumped = true;
                            } else {
                                if (boardState[nr][nc] !== EMPTY) {
                                    if (isEnemy(piece, boardState[nr][nc])) moves.push({ row: nr, col: nc });
                                    break;
                                }
                            }
                        }
                    });
                    break;
                case 7:
                    const forward = isRedPiece ? -1 : 1;
                    const crossedRiver = isRedPiece ? row <= 4 : row >= 5;
                    addMove(row + forward, col);
                    if (crossedRiver) {
                        addMove(row, col - 1);
                        addMove(row, col + 1);
                    }
                    break;
            }
            return moves;
        }

        function isInCheck(isRedPlayer, boardState = board) {
            let kingRow = -1, kingCol = -1;
            const kingPiece = isRedPlayer ? R_GENERAL : B_GENERAL;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (boardState[r][c] === kingPiece) {
                        kingRow = r; kingCol = c;
                        break;
                    }
                }
            }

            if (kingRow === -1) return true;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = boardState[r][c];
                    if (piece !== EMPTY && (isRedPlayer ? isBlack(piece) : isRed(piece))) {
                        const moves = getValidMoves(r, c, boardState);
                        if (moves.some(m => m.row === kingRow && m.col === kingCol)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function makeMoveOnBoard(fromRow, fromCol, toRow, toCol, boardState) {
            const captured = boardState[toRow][toCol];
            boardState[toRow][toCol] = boardState[fromRow][fromCol];
            boardState[fromRow][fromCol] = EMPTY;
            return captured;
        }

        function getLegalMoves(row, col, boardState = board) {
            const piece = boardState[row][col];
            const isRedPiece = isRed(piece);
            const moves = getValidMoves(row, col, boardState);

            return moves.filter(move => {
                const testBoard = boardState.map(r => [...r]);
                makeMoveOnBoard(row, col, move.row, move.col, testBoard);
                return !isInCheck(isRedPiece, testBoard);
            });
        }

        function hasLegalMoves(isRedPlayer, boardState = board) {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = boardState[r][c];
                    if (piece !== EMPTY && (isRedPlayer ? isRed(piece) : isBlack(piece))) {
                        if (getLegalMoves(r, c, boardState).length > 0) return true;
                    }
                }
            }
            return false;
        }

        // Track if opponent has joined (for online games)
        let opponentJoined = false;

        function handleInteraction(clientX, clientY) {
            // Don't allow moves if waiting for opponent in online game
            if (!isAIGame && !opponentJoined) return;
            if (gameOver || currentPlayer !== myColor || !gameStarted || aiThinking) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;

            const col = Math.round((x - MARGIN) / CELL_SIZE);
            const row = Math.round((y - MARGIN) / CELL_SIZE);

            if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return;

            const clickedPiece = board[row][col];

            const moveIndex = validMoves.findIndex(m => m.row === row && m.col === col);
            if (moveIndex !== -1 && selectedPiece) {
                const captured = board[row][col];

                if (isAIGame) {
                    // Save state before move for undo
                    saveToHistory();

                    // AI game - update local state
                    makeMoveOnBoard(selectedPiece.row, selectedPiece.col, row, col, board);

                    lastMove = {
                        fromRow: selectedPiece.row,
                        fromCol: selectedPiece.col,
                        toRow: row,
                        toCol: col
                    };

                    if (captured !== EMPTY) {
                        playSound('capture');
                    } else {
                        playSound('move');
                    }

                    if (captured === B_GENERAL || !hasLegalMoves(false, board)) {
                        gameOver = true;
                        stopGameTimer();
                        statusEl.textContent = 'ä½ èµ¢äº†!';
                        playSound('victory');
                        updateUserStats('win');
                        document.getElementById('rematchBtn').style.display = 'inline-block';
                    } else if (isInCheck(false, board)) {
                        playSound('check');
                        currentPlayer = 'black';
                        // Update timer after player move
                        redMoveCount++;
                        resetMoveTimer();
                        setTimeout(makeAIMove, 300);
                    } else {
                        currentPlayer = 'black';
                        // Update timer after player move
                        redMoveCount++;
                        resetMoveTimer();
                        setTimeout(makeAIMove, 300);
                    }

                    selectedPiece = null;
                    validMoves = [];
                    updateAIGameUI();
                    updateTimerDisplay();
                    drawBoard();
                    return;
                }

                // Online game - update Firebase
                const newBoard = board.map(r => [...r]);
                makeMoveOnBoard(selectedPiece.row, selectedPiece.col, row, col, newBoard);

                const newLastMove = {
                    fromRow: selectedPiece.row,
                    fromCol: selectedPiece.col,
                    toRow: row,
                    toCol: col
                };

                const nextPlayer = myColor === 'red' ? 'black' : 'red';
                const opponentIsRed = nextPlayer === 'red';
                const inCheck = isInCheck(opponentIsRed, newBoard);
                const opponentHasMoves = hasLegalMoves(opponentIsRed, newBoard);

                let isGameOver = false;
                let winner = null;

                if (captured === B_GENERAL || captured === R_GENERAL || !opponentHasMoves) {
                    isGameOver = true;
                    winner = myColor;
                }

                if (captured !== EMPTY) {
                    playSound('capture');
                } else {
                    playSound('move');
                }
                if (inCheck && !isGameOver) {
                    playSound('check');
                }
                if (isGameOver) {
                    playSound('victory');
                }

                // Save current state for undo before updating
                const previousState = {
                    board: board.map(r => [...r]),
                    currentPlayer: currentPlayer,
                    lastMove: lastMove,
                    redMoveCount: redMoveCount,
                    blackMoveCount: blackMoveCount,
                    redTimeRemaining: redTimeRemaining,
                    blackTimeRemaining: blackTimeRemaining
                };

                // Update move count and timer for online game
                if (myColor === 'red') {
                    redMoveCount++;
                } else {
                    blackMoveCount++;
                }

                gameRef.update({
                    board: newBoard,
                    currentPlayer: nextPlayer,
                    lastMove: newLastMove,
                    lastMoveBy: myColor,
                    lastMoveWasCapture: captured !== EMPTY,
                    inCheck: inCheck,
                    gameOver: isGameOver,
                    winner: winner,
                    // Timer data
                    redTimeRemaining: redTimeRemaining,
                    blackTimeRemaining: blackTimeRemaining,
                    redMoveCount: redMoveCount,
                    blackMoveCount: blackMoveCount,
                    turnStartTime: Date.now(),
                    // Save previous state for undo
                    previousState: previousState,
                    undoRequest: null
                });

                // Reset local move timer (will be synced from Firebase)
                resetMoveTimer();

                selectedPiece = null;
                validMoves = [];
                return;
            }

            if (isMyPiece(clickedPiece)) {
                selectedPiece = { row, col };
                validMoves = getLegalMoves(row, col);
                playSound('select');
                drawBoard();
            } else {
                selectedPiece = null;
                validMoves = [];
                drawBoard();
            }
        }

        canvas.addEventListener('click', (e) => {
            handleInteraction(e.clientX, e.clientY);
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleInteraction(touch.clientX, touch.clientY);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>
