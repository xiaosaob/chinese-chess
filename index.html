<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>‰∏≠ÂõΩË±°Ê£ã - Âú®Á∫øÂØπÊàò</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        html, body {
            overflow-x: hidden;
            touch-action: manipulation;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Microsoft YaHei', 'SimHei', -apple-system, sans-serif;
        }
        .game-container {
            text-align: center;
            padding: 10px;
            width: 100%;
            max-width: 600px;
        }
        h1 {
            color: #f4d03f;
            margin-bottom: 8px;
            font-size: clamp(24px, 6vw, 32px);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .status {
            color: #fff;
            font-size: clamp(16px, 4vw, 20px);
            margin-bottom: 8px;
            min-height: 28px;
        }
        .player-info {
            color: #4ecca3;
            font-size: clamp(14px, 3.5vw, 16px);
            margin-bottom: 8px;
        }
        .board-container {
            display: inline-block;
            padding: clamp(8px, 2vw, 20px);
            background: #d4a056;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 100%;
            overflow: hidden;
        }
        canvas {
            cursor: pointer;
            touch-action: none;
            max-width: 100%;
            height: auto;
        }
        .controls {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
        }
        button {
            padding: 12px 20px;
            font-size: clamp(14px, 3.5vw, 18px);
            background: #c0392b;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            transition: background 0.3s;
            touch-action: manipulation;
            min-height: 44px;
        }
        button:hover, button:active {
            background: #e74c3c;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .btn-google {
            background: #4285f4;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 0 auto 15px;
        }
        .btn-google:hover {
            background: #357abd;
        }
        .btn-guest {
            background: #95a5a6;
            display: block;
            width: 100%;
            margin: 10px auto;
        }
        .btn-guest:hover {
            background: #7f8c8d;
        }
        .btn-logout {
            background: #666;
            padding: 8px 15px;
            font-size: 14px;
        }
        .lobby {
            background: rgba(0,0,0,0.8);
            padding: clamp(20px, 5vw, 40px);
            border-radius: 15px;
            max-width: 500px;
            width: calc(100% - 20px);
            margin: 0 auto;
        }
        .lobby h2 {
            color: #f4d03f;
            margin-bottom: 15px;
            font-size: clamp(20px, 5vw, 28px);
        }
        .lobby p {
            color: #fff;
            margin-bottom: 12px;
            font-size: clamp(14px, 3.5vw, 16px);
        }
        .lobby input {
            padding: 12px 15px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            width: 100%;
            margin-bottom: 12px;
            text-align: center;
            min-height: 44px;
        }
        .share-link {
            background: #2c3e50;
            padding: 12px;
            border-radius: 5px;
            margin: 12px 0;
            word-break: break-all;
            font-size: clamp(12px, 3vw, 14px);
        }
        .share-link a {
            color: #3498db;
            text-decoration: none;
        }
        .waiting {
            color: #f4d03f;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 100;
        }
        .connected {
            background: #27ae60;
            color: white;
        }
        .disconnected {
            background: #c0392b;
            color: white;
        }
        .game-area {
            display: none;
        }
        .copy-btn {
            padding: 10px 20px;
            font-size: clamp(14px, 3.5vw, 16px);
            background: #3498db;
        }
        .copy-btn:hover, .copy-btn:active {
            background: #2980b9;
        }

        /* User profile styles */
        .user-profile {
            background: #2c3e50;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
            text-align: left;
        }
        .user-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 2px solid #f4d03f;
        }
        .user-info {
            flex: 1;
        }
        .user-name {
            color: #f4d03f;
            font-size: 18px;
            font-weight: bold;
        }
        .user-stats {
            color: #aaa;
            font-size: 14px;
            margin-top: 5px;
        }
        .user-stats span {
            margin-right: 10px;
        }
        .win { color: #27ae60; }
        .loss { color: #c0392b; }
        .draw { color: #f39c12; }

        /* Leaderboard styles */
        .leaderboard {
            background: #2c3e50;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        .leaderboard h3 {
            color: #f4d03f;
            margin-bottom: 10px;
            font-size: 18px;
        }
        .leaderboard-item {
            display: flex;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #3a4a5c;
            gap: 10px;
        }
        .leaderboard-item:last-child {
            border-bottom: none;
        }
        .leaderboard-rank {
            width: 30px;
            font-weight: bold;
            color: #f4d03f;
        }
        .leaderboard-rank.gold { color: #ffd700; }
        .leaderboard-rank.silver { color: #c0c0c0; }
        .leaderboard-rank.bronze { color: #cd7f32; }
        .leaderboard-avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
        }
        .leaderboard-name {
            flex: 1;
            color: #fff;
            font-size: 14px;
        }
        .leaderboard-score {
            color: #4ecca3;
            font-weight: bold;
        }

        /* Login screen */
        .login-section {
            text-align: center;
        }
        .login-section p {
            color: #888;
            margin-bottom: 20px;
        }
        .auth-divider {
            display: flex;
            align-items: center;
            margin: 20px 0;
            color: #666;
        }
        .auth-divider::before,
        .auth-divider::after {
            content: '';
            flex: 1;
            height: 1px;
            background: #444;
        }
        .auth-divider span {
            padding: 0 15px;
            font-size: 14px;
        }
        .auth-form input {
            width: 100%;
            padding: 12px 15px;
            margin-bottom: 10px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            text-align: left;
        }
        .auth-form input::placeholder {
            color: #999;
        }
        .btn-email {
            background: #27ae60;
            width: 100%;
            margin-bottom: 10px;
        }
        .btn-email:hover {
            background: #2ecc71;
        }
        .auth-toggle {
            color: #3498db;
            cursor: pointer;
            font-size: 14px;
            text-decoration: underline;
        }
        .auth-toggle:hover {
            color: #5dade2;
        }
        .auth-error {
            color: #e74c3c;
            font-size: 14px;
            margin-bottom: 10px;
            display: none;
        }
        .forgot-password {
            color: #888;
            font-size: 13px;
            cursor: pointer;
            margin-top: 5px;
        }
        .forgot-password:hover {
            color: #3498db;
        }
        .guest-prompt {
            background: rgba(241, 196, 15, 0.2);
            border: 1px solid #f1c40f;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 15px;
        }
        .guest-prompt p {
            color: #f1c40f;
            font-size: 13px;
            margin: 0;
        }
        .guest-badge {
            background: #95a5a6;
            color: white;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 8px;
            vertical-align: middle;
        }
        .upgrade-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .upgrade-modal.show {
            display: flex;
        }
        .upgrade-content {
            background: #1a1a2e;
            padding: 30px;
            border-radius: 15px;
            max-width: 400px;
            width: calc(100% - 40px);
            text-align: center;
        }
        .upgrade-content h3 {
            color: #f4d03f;
            margin-bottom: 15px;
        }
        .upgrade-content p {
            color: #aaa;
            margin-bottom: 20px;
            font-size: 14px;
        }
        .upgrade-content .auth-form {
            text-align: left;
        }
        .close-modal {
            background: #666;
            margin-top: 10px;
        }

        /* Game mode selection */
        .mode-selection {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }
        .mode-card {
            flex: 1;
            background: #2c3e50;
            border: 2px solid #3a4a5c;
            border-radius: 10px;
            padding: 20px 15px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .mode-card:hover {
            border-color: #4ecca3;
            transform: translateY(-2px);
        }
        .mode-card.selected {
            border-color: #4ecca3;
            background: rgba(78, 204, 163, 0.1);
        }
        .mode-card .icon {
            font-size: 36px;
            margin-bottom: 10px;
        }
        .mode-card .title {
            color: #fff;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .mode-card .desc {
            color: #888;
            font-size: 12px;
        }
        .difficulty-select {
            margin: 15px 0;
            display: none;
        }
        .difficulty-select.show {
            display: block;
        }
        .difficulty-select label {
            color: #aaa;
            font-size: 14px;
            margin-right: 10px;
        }
        .difficulty-select select {
            padding: 8px 15px;
            font-size: 14px;
            border-radius: 5px;
            border: none;
            background: #3a4a5c;
            color: #fff;
        }

        /* Game player names */
        .game-players {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 0 10px;
        }
        .game-player {
            background: #2c3e50;
            padding: 8px 15px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .game-player img {
            width: 24px;
            height: 24px;
            border-radius: 50%;
        }
        .game-player.red { border: 2px solid #c41e3a; }
        .game-player.black { border: 2px solid #333; }
        .game-player.active {
            box-shadow: 0 0 10px rgba(78, 204, 163, 0.8);
            border-color: #4ecca3;
        }

        /* Tabs */
        .tabs {
            display: flex;
            margin-bottom: 15px;
            border-radius: 5px;
            overflow: hidden;
        }
        .tab {
            flex: 1;
            padding: 10px;
            background: #3a4a5c;
            color: #aaa;
            border: none;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            min-height: 40px;
        }
        .tab.active {
            background: #4ecca3;
            color: #1a1a2e;
            font-weight: bold;
        }

        /* Mobile-specific adjustments */
        @media (max-width: 520px) {
            .game-container {
                padding: 5px;
            }
            .board-container {
                padding: 5px;
                border-radius: 8px;
            }
            .controls {
                padding: 0 5px;
            }
            button {
                padding: 10px 15px;
                flex: 1 1 auto;
                min-width: 80px;
            }
            .user-profile {
                padding: 10px;
            }
            .user-avatar {
                width: 40px;
                height: 40px;
            }
            .game-players {
                flex-direction: column;
                gap: 5px;
            }
        }
    </style>
</head>
<body>
    <div class="connection-status disconnected" id="connectionStatus">Êú™ËøûÊé•</div>

    <div class="game-container">
        <!-- Login Screen -->
        <div class="lobby" id="loginScreen">
            <h2>‰∏≠ÂõΩË±°Ê£ã - Âú®Á∫øÂØπÊàò</h2>
            <div class="login-section">
                <p>ÁôªÂΩï‰ª•‰øùÂ≠ò‰Ω†ÁöÑÊàòÁª©Âπ∂‰∏éÊúãÂèãÂØπÊàò</p>
                <button class="btn-google" onclick="signInWithGoogle()">
                    <svg width="18" height="18" viewBox="0 0 18 18"><path fill="#fff" d="M16.51 8H8.98v3h4.3c-.18 1-.74 1.48-1.6 2.04v2.01h2.6a7.8 7.8 0 0 0 2.38-5.88c0-.57-.05-.66-.15-1.18z"/><path fill="#fff" d="M8.98 17c2.16 0 3.97-.72 5.3-1.94l-2.6-2a4.8 4.8 0 0 1-7.18-2.54H1.83v2.07A8 8 0 0 0 8.98 17z"/><path fill="#fff" d="M4.5 10.52a4.8 4.8 0 0 1 0-3.04V5.41H1.83a8 8 0 0 0 0 7.18l2.67-2.07z"/><path fill="#fff" d="M8.98 4.18c1.17 0 2.23.4 3.06 1.2l2.3-2.3A8 8 0 0 0 1.83 5.4L4.5 7.49a4.77 4.77 0 0 1 4.48-3.3z"/></svg>
                    ‰ΩøÁî® Google ÁôªÂΩï
                </button>

                <button class="btn-guest" onclick="signInAsGuest()">
                    Ê∏∏ÂÆ¢Ê®°Âºè
                </button>

                <div class="auth-divider"><span>Êàñ‰ΩøÁî®ÈÇÆÁÆ±</span></div>

                <div class="auth-form">
                    <div class="auth-error" id="authError"></div>
                    <input type="text" id="displayNameInput" placeholder="ÊòµÁß∞ (‰ªÖÊ≥®ÂÜåÊó∂ÈúÄË¶Å)" style="display: none;">
                    <input type="email" id="emailInput" placeholder="ÈÇÆÁÆ±Âú∞ÂùÄ">
                    <input type="password" id="passwordInput" placeholder="ÂØÜÁ†Å (Ëá≥Â∞ë6‰Ωç)">
                    <button class="btn-email" id="authBtn" onclick="handleEmailAuth()">ÁôªÂΩï</button>
                    <p>
                        <span class="auth-toggle" id="authToggle" onclick="toggleAuthMode()">Ê≤°ÊúâË¥¶Âè∑ÔºüÁÇπÂáªÊ≥®ÂÜå</span>
                    </p>
                    <p class="forgot-password" onclick="handleForgotPassword()">ÂøòËÆ∞ÂØÜÁ†ÅÔºü</p>
                </div>
            </div>
        </div>

        <!-- Lobby -->
        <div class="lobby" id="lobby" style="display: none;">
            <h2>‰∏≠ÂõΩË±°Ê£ã - Âú®Á∫øÂØπÊàò</h2>

            <!-- User Profile -->
            <div class="user-profile" id="userProfile">
                <img class="user-avatar" id="userAvatar" src="" alt="avatar">
                <div class="user-info">
                    <div class="user-name" id="userName">Áé©ÂÆ∂</div>
                    <div class="user-stats">
                        <span class="win" id="userWins">ËÉú: 0</span>
                        <span class="loss" id="userLosses">Ë¥ü: 0</span>
                        <span class="draw" id="userDraws">Âíå: 0</span>
                    </div>
                </div>
                <button class="btn-logout" onclick="signOut()">ÁôªÂá∫</button>
            </div>
            <!-- Guest upgrade prompt -->
            <div class="guest-prompt" id="guestPrompt" style="display: none;">
                <p>Ê∏∏ÂÆ¢Êï∞ÊçÆÂ∞ÜÂú®ÁôªÂá∫Âêé‰∏¢Â§±Ôºå<span class="auth-toggle" onclick="showUpgradeModal()">ÁÇπÂáªÂçáÁ∫ßË¥¶Âè∑</span>‰øùÂ≠òÊàòÁª©</p>
            </div>

            <!-- Tabs -->
            <div class="tabs">
                <button class="tab active" onclick="showTab('play')">ÂºÄÂßãÊ∏∏Êàè</button>
                <button class="tab" onclick="showTab('leaderboard')">ÊéíË°åÊ¶ú</button>
            </div>

            <!-- Play Tab -->
            <div id="playTab">
                <!-- Mode Selection -->
                <div class="mode-selection" id="modeSelection">
                    <div class="mode-card selected" onclick="selectMode('ai')" id="modeAI">
                        <div class="icon">ü§ñ</div>
                        <div class="title">‰∫∫Êú∫ÂØπÊàò</div>
                        <div class="desc">‰∏éAIÂØπÂºà</div>
                    </div>
                    <div class="mode-card" onclick="selectMode('online')" id="modeOnline">
                        <div class="icon">üë•</div>
                        <div class="title">Âú®Á∫øÂØπÊàò</div>
                        <div class="desc">‰∏éÊúãÂèãÂØπÂºà</div>
                    </div>
                </div>

                <!-- AI Mode Options -->
                <div class="difficulty-select show" id="aiOptions">
                    <label>ÈöæÂ∫¶:</label>
                    <select id="aiDifficulty">
                        <option value="2">ÁÆÄÂçï</option>
                        <option value="3" selected>‰∏≠Á≠â</option>
                        <option value="4">Âõ∞Èöæ</option>
                    </select>
                </div>

                <!-- Start AI Game Button -->
                <div id="aiSection">
                    <button onclick="startAIGame()">ÂºÄÂßãÊ∏∏Êàè</button>
                </div>

                <!-- Online Mode Options -->
                <div id="createSection" style="display: none;">
                    <button onclick="createGame()">ÂàõÂª∫Êñ∞Ê∏∏Êàè</button>
                    <p style="margin: 20px 0; color: #888;">- ÊàñËÄÖ -</p>
                    <input type="text" id="joinRoomId" placeholder="ËæìÂÖ•ÊàøÈó¥Âè∑Âä†ÂÖ•Ê∏∏Êàè">
                    <button onclick="joinGame()">Âä†ÂÖ•Ê∏∏Êàè</button>
                </div>

                <div id="waitingSection" style="display: none;">
                    <p class="waiting">Á≠âÂæÖÂØπÊâãÂä†ÂÖ•...</p>
                    <div class="share-link">
                        <p style="color: #888; font-size: 14px;">ÂàÜ‰∫´Ê≠§ÈìæÊé•ÁªôÊúãÂèã:</p>
                        <a id="shareLink" href="#" target="_blank"></a>
                    </div>
                    <button class="copy-btn" onclick="copyLink()">Â§çÂà∂ÈìæÊé•</button>
                    <p style="margin-top: 15px; color: #888; font-size: 14px;">ÊàøÈó¥Âè∑: <span id="roomIdDisplay"></span></p>
                    <button style="margin-top: 15px; background: #666;" onclick="cancelWaiting()">ÂèñÊ∂à</button>
                </div>
            </div>

            <!-- Leaderboard Tab -->
            <div id="leaderboardTab" style="display: none;">
                <div class="leaderboard" id="leaderboard">
                    <h3>üèÜ ÊéíË°åÊ¶ú</h3>
                    <div id="leaderboardList">
                        <p style="color: #888; text-align: center;">Âä†ËΩΩ‰∏≠...</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Game Area -->
        <div class="game-area" id="gameArea">
            <h1>‰∏≠ÂõΩË±°Ê£ã</h1>
            <div class="game-players" id="gamePlayers">
                <div class="game-player red" id="redPlayerInfo">
                    <img src="" alt="">
                    <span>Á∫¢Êñπ</span>
                </div>
                <div class="game-player black" id="blackPlayerInfo">
                    <img src="" alt="">
                    <span>ÈªëÊñπ</span>
                </div>
            </div>
            <div class="status" id="status">Á∫¢ÊñπÂÖàË°å</div>
            <div class="board-container">
                <canvas id="board" width="520" height="580"></canvas>
            </div>
            <div class="controls">
                <button onclick="requestRematch()" id="rematchBtn" style="display:none;">ÂÜçÊù•‰∏ÄÂ±Ä</button>
                <button onclick="leaveGame()">Á¶ªÂºÄÊ∏∏Êàè</button>
                <button id="soundBtn" onclick="toggleSound()">ÂÖ≥Èó≠Èü≥Êïà</button>
            </div>
        </div>
    </div>

    <!-- Upgrade Modal for Guests -->
    <div class="upgrade-modal" id="upgradeModal">
        <div class="upgrade-content">
            <h3>ÂçáÁ∫ßË¥¶Âè∑</h3>
            <p>ÂÖ≥ËÅîÈÇÆÁÆ±‰ª•Ê∞∏‰πÖ‰øùÂ≠ò‰Ω†ÁöÑÊàòÁª©</p>
            <div class="auth-form">
                <div class="auth-error" id="upgradeError"></div>
                <input type="email" id="upgradeEmail" placeholder="ÈÇÆÁÆ±Âú∞ÂùÄ">
                <input type="password" id="upgradePassword" placeholder="ËÆæÁΩÆÂØÜÁ†Å (Ëá≥Â∞ë6‰Ωç)">
                <button class="btn-email" onclick="upgradeGuestAccount()">ÂçáÁ∫ßË¥¶Âè∑</button>
                <button class="close-modal" onclick="hideUpgradeModal()">ÂèñÊ∂à</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>

    <script>
        // ============================================
        // FIREBASE CONFIGURATION
        // ============================================
        const firebaseConfig = {
            apiKey: "AIzaSyDsV1zjfCwYXoq6Ua3AZ4QVbLt1Sdgyd0Y",
            authDomain: "chinese-chess-9a981.firebaseapp.com",
            databaseURL: "https://chinese-chess-9a981-default-rtdb.firebaseio.com",
            projectId: "chinese-chess-9a981",
            storageBucket: "chinese-chess-9a981.firebasestorage.app",
            messagingSenderId: "1085517521136",
            appId: "1:1085517521136:web:636b9648a132ce740da235",
            measurementId: "G-Z9Y2LS56EL"
        };

        // Initialize Firebase
        let db = null;
        let auth = null;
        let currentUser = null;
        let userProfile = null;
        let gameRef = null;
        let roomId = null;
        let myColor = null;
        let gameStarted = false;
        let opponentProfile = null;
        let isAIGame = false;
        let aiDepth = 3;
        let aiThinking = false;

        try {
            firebase.initializeApp(firebaseConfig);
            db = firebase.database();
            auth = firebase.auth();
            document.getElementById('connectionStatus').className = 'connection-status connected';
            document.getElementById('connectionStatus').textContent = 'Â∑≤ËøûÊé•';
        } catch (e) {
            console.error('Firebase initialization failed:', e);
            alert('Firebase ÈÖçÁΩÆÈîôËØØÔºåËØ∑Ê£ÄÊü•ÈÖçÁΩÆ‰ø°ÊÅØ');
        }

        // ============================================
        // AUTHENTICATION
        // ============================================
        let isSignUpMode = false;

        function signInWithGoogle() {
            const provider = new firebase.auth.GoogleAuthProvider();
            auth.signInWithPopup(provider).catch((error) => {
                console.error('Login error:', error);
                showAuthError('GoogleÁôªÂΩïÂ§±Ë¥•: ' + getErrorMessage(error.code));
            });
        }

        function signOut() {
            auth.signOut();
        }

        async function signInAsGuest() {
            try {
                await auth.signInAnonymously();
            } catch (error) {
                console.error('Guest login error:', error);
                showAuthError('Ê∏∏ÂÆ¢ÁôªÂΩïÂ§±Ë¥•: ' + getErrorMessage(error.code));
            }
        }

        function toggleAuthMode() {
            isSignUpMode = !isSignUpMode;
            const btn = document.getElementById('authBtn');
            const toggle = document.getElementById('authToggle');
            const nameInput = document.getElementById('displayNameInput');

            if (isSignUpMode) {
                btn.textContent = 'Ê≥®ÂÜå';
                toggle.textContent = 'Â∑≤ÊúâË¥¶Âè∑ÔºüÁÇπÂáªÁôªÂΩï';
                nameInput.style.display = 'block';
            } else {
                btn.textContent = 'ÁôªÂΩï';
                toggle.textContent = 'Ê≤°ÊúâË¥¶Âè∑ÔºüÁÇπÂáªÊ≥®ÂÜå';
                nameInput.style.display = 'none';
            }
            hideAuthError();
        }

        function showAuthError(message) {
            const errorEl = document.getElementById('authError');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        function hideAuthError() {
            document.getElementById('authError').style.display = 'none';
        }

        function getErrorMessage(code) {
            const messages = {
                'auth/email-already-in-use': 'ËØ•ÈÇÆÁÆ±Â∑≤Ë¢´Ê≥®ÂÜå',
                'auth/invalid-email': 'ÈÇÆÁÆ±Ê†ºÂºè‰∏çÊ≠£Á°Æ',
                'auth/operation-not-allowed': 'ÈÇÆÁÆ±ÁôªÂΩïÊú™ÂêØÁî®',
                'auth/weak-password': 'ÂØÜÁ†ÅÂ§™Âº±ÔºåËØ∑Ëá≥Â∞ë‰ΩøÁî®6‰ΩçÂ≠óÁ¨¶',
                'auth/user-disabled': 'ËØ•Ë¥¶Êà∑Â∑≤Ë¢´Á¶ÅÁî®',
                'auth/user-not-found': 'Áî®Êà∑‰∏çÂ≠òÂú®',
                'auth/wrong-password': 'ÂØÜÁ†ÅÈîôËØØ',
                'auth/invalid-credential': 'ÈÇÆÁÆ±ÊàñÂØÜÁ†ÅÈîôËØØ',
                'auth/too-many-requests': 'Â∞ùËØïÊ¨°Êï∞ËøáÂ§öÔºåËØ∑Á®çÂêéÂÜçËØï'
            };
            return messages[code] || 'Êìç‰ΩúÂ§±Ë¥•ÔºåËØ∑ÈáçËØï';
        }

        async function handleEmailAuth() {
            const email = document.getElementById('emailInput').value.trim();
            const password = document.getElementById('passwordInput').value;
            const displayName = document.getElementById('displayNameInput').value.trim();

            hideAuthError();

            if (!email || !password) {
                showAuthError('ËØ∑ËæìÂÖ•ÈÇÆÁÆ±ÂíåÂØÜÁ†Å');
                return;
            }

            if (isSignUpMode && !displayName) {
                showAuthError('ËØ∑ËæìÂÖ•ÊòµÁß∞');
                return;
            }

            try {
                if (isSignUpMode) {
                    // Sign up
                    const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                    // Update display name
                    await userCredential.user.updateProfile({
                        displayName: displayName,
                        photoURL: generateAvatarUrl(displayName)
                    });
                    // Reload to get updated profile
                    await userCredential.user.reload();
                } else {
                    // Sign in
                    await auth.signInWithEmailAndPassword(email, password);
                }
            } catch (error) {
                console.error('Auth error:', error);
                showAuthError(getErrorMessage(error.code));
            }
        }

        function generateAvatarUrl(name) {
            // Generate a simple avatar using UI Avatars API
            const encodedName = encodeURIComponent(name || 'Player');
            return `https://ui-avatars.com/api/?name=${encodedName}&background=random&color=fff&size=100`;
        }

        async function handleForgotPassword() {
            const email = document.getElementById('emailInput').value.trim();

            if (!email) {
                showAuthError('ËØ∑ÂÖàËæìÂÖ•ÈÇÆÁÆ±Âú∞ÂùÄ');
                return;
            }

            try {
                await auth.sendPasswordResetEmail(email);
                alert('ÂØÜÁ†ÅÈáçÁΩÆÈÇÆ‰ª∂Â∑≤ÂèëÈÄÅÂà∞ ' + email + 'ÔºåËØ∑Êü•Êî∂');
            } catch (error) {
                console.error('Password reset error:', error);
                showAuthError(getErrorMessage(error.code));
            }
        }

        // Handle Enter key in password field
        document.addEventListener('DOMContentLoaded', () => {
            const passwordInput = document.getElementById('passwordInput');
            if (passwordInput) {
                passwordInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        handleEmailAuth();
                    }
                });
            }
        });

        auth.onAuthStateChanged(async (user) => {
            if (user) {
                currentUser = user;
                await loadOrCreateUserProfile(user);
                document.getElementById('loginScreen').style.display = 'none';
                document.getElementById('lobby').style.display = 'block';
                updateProfileUI();
                loadLeaderboard();

                // Check URL for room ID after login
                const urlParams = new URLSearchParams(window.location.search);
                const urlRoomId = urlParams.get('room');
                if (urlRoomId) {
                    document.getElementById('joinRoomId').value = urlRoomId;
                    joinGame();
                }
            } else {
                currentUser = null;
                userProfile = null;
                document.getElementById('loginScreen').style.display = 'block';
                document.getElementById('lobby').style.display = 'none';
            }
        });

        async function loadOrCreateUserProfile(user) {
            const userRef = db.ref('users/' + user.uid);
            const snapshot = await userRef.once('value');

            // Generate name and avatar for guests/email users
            const isGuest = user.isAnonymous;
            const guestName = 'Ê∏∏ÂÆ¢' + user.uid.substring(0, 4).toUpperCase();
            const displayName = user.displayName || user.email?.split('@')[0] || guestName;
            const photoURL = user.photoURL || generateAvatarUrl(displayName);

            if (snapshot.exists()) {
                userProfile = snapshot.val();
                // Keep existing name for guests if already set, otherwise update
                const updatedName = isGuest && userProfile.displayName ? userProfile.displayName : displayName;
                await userRef.update({
                    displayName: updatedName,
                    photoURL: photoURL,
                    isGuest: isGuest
                });
                userProfile.displayName = updatedName;
                userProfile.photoURL = photoURL;
                userProfile.isGuest = isGuest;
            } else {
                userProfile = {
                    displayName: displayName,
                    photoURL: photoURL,
                    wins: 0,
                    losses: 0,
                    draws: 0,
                    gamesPlayed: 0,
                    isGuest: isGuest,
                    createdAt: Date.now()
                };
                await userRef.set(userProfile);
            }
        }

        function updateProfileUI() {
            if (userProfile) {
                document.getElementById('userAvatar').src = userProfile.photoURL || 'https://via.placeholder.com/50';

                const nameEl = document.getElementById('userName');
                const guestPrompt = document.getElementById('guestPrompt');

                if (userProfile.isGuest) {
                    nameEl.innerHTML = (userProfile.displayName || 'Ê∏∏ÂÆ¢') + '<span class="guest-badge">Ê∏∏ÂÆ¢</span>';
                    guestPrompt.style.display = 'block';
                } else {
                    nameEl.textContent = userProfile.displayName || 'Áé©ÂÆ∂';
                    guestPrompt.style.display = 'none';
                }

                document.getElementById('userWins').textContent = 'ËÉú: ' + (userProfile.wins || 0);
                document.getElementById('userLosses').textContent = 'Ë¥ü: ' + (userProfile.losses || 0);
                document.getElementById('userDraws').textContent = 'Âíå: ' + (userProfile.draws || 0);
            }
        }

        function showUpgradeModal() {
            document.getElementById('upgradeModal').classList.add('show');
            document.getElementById('upgradeError').style.display = 'none';
        }

        function hideUpgradeModal() {
            document.getElementById('upgradeModal').classList.remove('show');
        }

        async function upgradeGuestAccount() {
            const email = document.getElementById('upgradeEmail').value.trim();
            const password = document.getElementById('upgradePassword').value;
            const errorEl = document.getElementById('upgradeError');

            errorEl.style.display = 'none';

            if (!email || !password) {
                errorEl.textContent = 'ËØ∑ËæìÂÖ•ÈÇÆÁÆ±ÂíåÂØÜÁ†Å';
                errorEl.style.display = 'block';
                return;
            }

            try {
                const credential = firebase.auth.EmailAuthProvider.credential(email, password);
                await currentUser.linkWithCredential(credential);

                // Update profile
                userProfile.isGuest = false;
                await db.ref('users/' + currentUser.uid).update({ isGuest: false });

                hideUpgradeModal();
                updateProfileUI();
                alert('Ë¥¶Âè∑ÂçáÁ∫ßÊàêÂäüÔºÅ‰Ω†ÁöÑÊàòÁª©Â∑≤Ê∞∏‰πÖ‰øùÂ≠ò„ÄÇ');
            } catch (error) {
                console.error('Upgrade error:', error);
                errorEl.textContent = getErrorMessage(error.code);
                errorEl.style.display = 'block';
            }
        }

        async function updateUserStats(result) {
            if (!currentUser) return;

            const userRef = db.ref('users/' + currentUser.uid);
            const updates = {
                gamesPlayed: (userProfile.gamesPlayed || 0) + 1
            };

            if (result === 'win') {
                updates.wins = (userProfile.wins || 0) + 1;
                userProfile.wins = updates.wins;
            } else if (result === 'loss') {
                updates.losses = (userProfile.losses || 0) + 1;
                userProfile.losses = updates.losses;
            } else if (result === 'draw') {
                updates.draws = (userProfile.draws || 0) + 1;
                userProfile.draws = updates.draws;
            }

            userProfile.gamesPlayed = updates.gamesPlayed;
            await userRef.update(updates);
            updateProfileUI();

            // Update leaderboard
            await updateLeaderboard();
        }

        async function updateLeaderboard() {
            if (!currentUser || !userProfile) return;

            const score = (userProfile.wins || 0) * 3 + (userProfile.draws || 0);
            await db.ref('leaderboard/' + currentUser.uid).set({
                displayName: userProfile.displayName,
                photoURL: userProfile.photoURL,
                wins: userProfile.wins || 0,
                losses: userProfile.losses || 0,
                draws: userProfile.draws || 0,
                score: score
            });
        }

        async function loadLeaderboard() {
            const leaderboardRef = db.ref('leaderboard').orderByChild('score').limitToLast(20);
            leaderboardRef.on('value', (snapshot) => {
                const data = snapshot.val();
                const list = document.getElementById('leaderboardList');

                if (!data) {
                    list.innerHTML = '<p style="color: #888; text-align: center;">ÊöÇÊó†Êï∞ÊçÆ</p>';
                    return;
                }

                // Convert to array and sort by score descending
                const players = Object.entries(data)
                    .map(([uid, player]) => ({ uid, ...player }))
                    .sort((a, b) => b.score - a.score);

                list.innerHTML = players.map((player, index) => {
                    const rankClass = index === 0 ? 'gold' : index === 1 ? 'silver' : index === 2 ? 'bronze' : '';
                    const isMe = currentUser && player.uid === currentUser.uid;
                    return `
                        <div class="leaderboard-item" style="${isMe ? 'background: rgba(78,204,163,0.2);' : ''}">
                            <div class="leaderboard-rank ${rankClass}">${index + 1}</div>
                            <img class="leaderboard-avatar" src="${player.photoURL || 'https://via.placeholder.com/30'}" alt="">
                            <div class="leaderboard-name">${player.displayName || 'Áé©ÂÆ∂'}${isMe ? ' (‰Ω†)' : ''}</div>
                            <div class="leaderboard-score">${player.score}ÂàÜ</div>
                        </div>
                    `;
                }).join('');
            });
        }

        // ============================================
        // UI HELPERS
        // ============================================
        let selectedGameMode = 'ai';

        function showTab(tab) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');

            document.getElementById('playTab').style.display = tab === 'play' ? 'block' : 'none';
            document.getElementById('leaderboardTab').style.display = tab === 'leaderboard' ? 'block' : 'none';
        }

        function selectMode(mode) {
            selectedGameMode = mode;

            document.getElementById('modeAI').classList.toggle('selected', mode === 'ai');
            document.getElementById('modeOnline').classList.toggle('selected', mode === 'online');

            document.getElementById('aiOptions').classList.toggle('show', mode === 'ai');
            document.getElementById('aiSection').style.display = mode === 'ai' ? 'block' : 'none';
            document.getElementById('createSection').style.display = mode === 'online' ? 'block' : 'none';
        }

        function cancelWaiting() {
            if (gameRef) {
                gameRef.off();
                gameRef.remove();
            }
            document.getElementById('createSection').style.display = 'block';
            document.getElementById('waitingSection').style.display = 'none';
        }

        // ============================================
        // AI GAME LOGIC
        // ============================================
        const pieceValues = {
            1: 10000, 2: 20, 3: 20, 4: 40, 5: 90, 6: 45, 7: 10,
            11: 10000, 12: 20, 13: 20, 14: 40, 15: 90, 16: 45, 17: 10
        };

        function startAIGame() {
            if (!currentUser) {
                alert('ËØ∑ÂÖàÁôªÂΩï');
                return;
            }

            isAIGame = true;
            aiDepth = parseInt(document.getElementById('aiDifficulty').value);
            myColor = 'red';
            gameStarted = true;
            gameOver = false;
            currentPlayer = 'red';

            document.getElementById('lobby').style.display = 'none';
            document.getElementById('gameArea').style.display = 'block';

            // Set up player info for AI game
            document.getElementById('redPlayerInfo').innerHTML = `
                <img src="${userProfile.photoURL || 'https://via.placeholder.com/24'}" alt="">
                <span>${userProfile.displayName || '‰Ω†'}</span>
            `;
            document.getElementById('blackPlayerInfo').innerHTML = `
                <img src="https://ui-avatars.com/api/?name=AI&background=333&color=fff&size=24" alt="">
                <span>AI (${aiDepth === 2 ? 'ÁÆÄÂçï' : aiDepth === 3 ? '‰∏≠Á≠â' : 'Âõ∞Èöæ'})</span>
            `;

            initBoard();
            resizeCanvas();
            updateAIGameUI();
            drawBoard();
        }

        function updateAIGameUI() {
            const redInfo = document.getElementById('redPlayerInfo');
            const blackInfo = document.getElementById('blackPlayerInfo');

            redInfo.classList.toggle('active', currentPlayer === 'red' && !gameOver);
            blackInfo.classList.toggle('active', currentPlayer === 'black' && !gameOver);

            if (gameOver) {
                // Game over handled elsewhere
            } else if (aiThinking) {
                statusEl.textContent = 'AIÊÄùËÄÉ‰∏≠...';
            } else if (currentPlayer === 'red') {
                statusEl.textContent = 'ËΩÆÂà∞‰Ω†Ëµ∞Ê£ã';
            } else {
                statusEl.textContent = 'Á≠âÂæÖAI...';
            }
        }

        function evaluateBoard(boardState) {
            let score = 0;
            const positionBonus = [
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [0, 0, 0, 0, 0, 0, 0, 0, 0],
                [1, 1, 3, 5, 5, 5, 3, 1, 1],
                [2, 4, 6, 8, 10, 8, 6, 4, 2],
                [3, 6, 9, 12, 15, 12, 9, 6, 3],
                [4, 8, 12, 16, 20, 16, 12, 8, 4],
                [5, 10, 15, 20, 25, 20, 15, 10, 5],
                [6, 12, 18, 24, 30, 24, 18, 12, 6],
                [0, 0, 0, 0, 0, 0, 0, 0, 0]
            ];

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = boardState[r][c];
                    if (piece === EMPTY) continue;

                    let value = pieceValues[piece] || 0;

                    if (piece === 7) value += positionBonus[r][c];
                    else if (piece === 17) value += positionBonus[9 - r][c];

                    const moves = getValidMoves(r, c, boardState);
                    value += moves.length * 0.5;

                    score += isRed(piece) ? -value : value;
                }
            }
            return score;
        }

        function getAllMovesForPlayer(isRedPlayer, boardState) {
            const moves = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = boardState[r][c];
                    if (piece !== EMPTY && (isRedPlayer ? isRed(piece) : isBlack(piece))) {
                        const pieceMoves = getLegalMoves(r, c, boardState);
                        pieceMoves.forEach(m => {
                            moves.push({ fromRow: r, fromCol: c, toRow: m.row, toCol: m.col });
                        });
                    }
                }
            }
            return moves;
        }

        function minimax(boardState, depth, alpha, beta, isMaximizing) {
            if (depth === 0) {
                return { score: evaluateBoard(boardState) };
            }

            const moves = getAllMovesForPlayer(!isMaximizing, boardState);

            if (moves.length === 0) {
                if (isInCheck(!isMaximizing, boardState)) {
                    return { score: isMaximizing ? -99999 : 99999 };
                }
                return { score: 0 };
            }

            let bestMove = null;

            if (isMaximizing) {
                let maxScore = -Infinity;
                for (const move of moves) {
                    const testBoard = boardState.map(r => [...r]);
                    makeMoveOnBoard(move.fromRow, move.fromCol, move.toRow, move.toCol, testBoard);
                    const result = minimax(testBoard, depth - 1, alpha, beta, false);

                    if (result.score > maxScore) {
                        maxScore = result.score;
                        bestMove = move;
                    }
                    alpha = Math.max(alpha, result.score);
                    if (beta <= alpha) break;
                }
                return { score: maxScore, move: bestMove };
            } else {
                let minScore = Infinity;
                for (const move of moves) {
                    const testBoard = boardState.map(r => [...r]);
                    makeMoveOnBoard(move.fromRow, move.fromCol, move.toRow, move.toCol, testBoard);
                    const result = minimax(testBoard, depth - 1, alpha, beta, true);

                    if (result.score < minScore) {
                        minScore = result.score;
                        bestMove = move;
                    }
                    beta = Math.min(beta, result.score);
                    if (beta <= alpha) break;
                }
                return { score: minScore, move: bestMove };
            }
        }

        function makeAIMove() {
            if (gameOver || currentPlayer !== 'black' || !isAIGame) return;

            aiThinking = true;
            updateAIGameUI();
            drawBoard();

            setTimeout(() => {
                const boardCopy = board.map(row => [...row]);
                const result = minimax(boardCopy, aiDepth, -Infinity, Infinity, true);

                if (result.move) {
                    const captured = board[result.move.toRow][result.move.toCol];
                    makeMoveOnBoard(result.move.fromRow, result.move.fromCol, result.move.toRow, result.move.toCol, board);

                    lastMove = {
                        fromRow: result.move.fromRow,
                        fromCol: result.move.fromCol,
                        toRow: result.move.toRow,
                        toCol: result.move.toCol
                    };

                    if (captured !== EMPTY) {
                        playSound('capture');
                    } else {
                        playSound('move');
                    }

                    if (captured === R_GENERAL) {
                        gameOver = true;
                        statusEl.textContent = '‰Ω†Ëæì‰∫Ü!';
                        playSound('defeat');
                        updateUserStats('loss');
                        document.getElementById('rematchBtn').style.display = 'inline-block';
                    } else if (isInCheck(true, board)) {
                        if (!hasLegalMoves(true, board)) {
                            gameOver = true;
                            statusEl.textContent = 'Â∞ÜÊ≠ªÔºÅ‰Ω†Ëæì‰∫Ü!';
                            playSound('defeat');
                            updateUserStats('loss');
                            document.getElementById('rematchBtn').style.display = 'inline-block';
                        } else {
                            currentPlayer = 'red';
                            playSound('check');
                        }
                    } else {
                        currentPlayer = 'red';
                    }
                } else {
                    gameOver = true;
                    statusEl.textContent = '‰Ω†Ëµ¢‰∫Ü!';
                    playSound('victory');
                    updateUserStats('win');
                    document.getElementById('rematchBtn').style.display = 'inline-block';
                }

                aiThinking = false;
                updateAIGameUI();
                drawBoard();
            }, 100);
        }

        // ============================================
        // ONLINE GAME LOGIC
        // ============================================
        function generateRoomId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function createGame() {
            if (!currentUser) {
                alert('ËØ∑ÂÖàÁôªÂΩï');
                return;
            }

            roomId = generateRoomId();
            myColor = 'red';

            gameRef = db.ref('games/' + roomId);

            const initialState = {
                board: getInitialBoard(),
                currentPlayer: 'red',
                redPlayer: {
                    odule: currentUser.uid,
                    displayName: userProfile.displayName,
                    photoURL: userProfile.photoURL
                },
                blackPlayer: null,
                lastMove: null,
                gameOver: false,
                winner: null,
                rematchRequest: null,
                statsUpdated: false,
                created: Date.now()
            };

            gameRef.set(initialState).then(() => {
                document.getElementById('createSection').style.display = 'none';
                document.getElementById('waitingSection').style.display = 'block';

                const shareUrl = window.location.origin + window.location.pathname + '?room=' + roomId;
                document.getElementById('shareLink').href = shareUrl;
                document.getElementById('shareLink').textContent = shareUrl;
                document.getElementById('roomIdDisplay').textContent = roomId;

                // Listen for opponent joining
                gameRef.child('blackPlayer').on('value', (snapshot) => {
                    if (snapshot.val()) {
                        opponentProfile = snapshot.val();
                        startGame();
                    }
                });
            });
        }

        function joinGame() {
            if (!currentUser) {
                alert('ËØ∑ÂÖàÁôªÂΩï');
                return;
            }

            roomId = document.getElementById('joinRoomId').value.trim().toUpperCase();
            if (!roomId) {
                alert('ËØ∑ËæìÂÖ•ÊàøÈó¥Âè∑');
                return;
            }

            gameRef = db.ref('games/' + roomId);

            gameRef.once('value').then((snapshot) => {
                const game = snapshot.val();
                if (!game) {
                    alert('ÊàøÈó¥‰∏çÂ≠òÂú®');
                    return;
                }
                if (game.blackPlayer) {
                    alert('ÊàøÈó¥Â∑≤Êª°');
                    return;
                }

                myColor = 'black';
                opponentProfile = game.redPlayer;

                gameRef.update({
                    blackPlayer: {
                        odule: currentUser.uid,
                        displayName: userProfile.displayName,
                        photoURL: userProfile.photoURL
                    }
                }).then(() => {
                    startGame();
                });
            });
        }

        function startGame() {
            gameStarted = true;
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('gameArea').style.display = 'block';

            initBoard();
            setupGameListeners();
            resizeCanvas();
            drawBoard();
        }

        function updatePlayerInfoUI(game) {
            const redInfo = document.getElementById('redPlayerInfo');
            const blackInfo = document.getElementById('blackPlayerInfo');

            if (game.redPlayer) {
                redInfo.innerHTML = `
                    <img src="${game.redPlayer.photoURL || 'https://via.placeholder.com/24'}" alt="">
                    <span>${game.redPlayer.displayName || 'Á∫¢Êñπ'}</span>
                `;
            }
            if (game.blackPlayer) {
                blackInfo.innerHTML = `
                    <img src="${game.blackPlayer.photoURL || 'https://via.placeholder.com/24'}" alt="">
                    <span>${game.blackPlayer.displayName || 'ÈªëÊñπ'}</span>
                `;
            }

            // Highlight current player
            redInfo.classList.toggle('active', game.currentPlayer === 'red' && !game.gameOver);
            blackInfo.classList.toggle('active', game.currentPlayer === 'black' && !game.gameOver);
        }

        function setupGameListeners() {
            gameRef.on('value', async (snapshot) => {
                const game = snapshot.val();
                if (!game) {
                    alert('Ê∏∏ÊàèÂ∑≤ÁªìÊùü');
                    leaveGame();
                    return;
                }

                // Update board state
                board = game.board;
                currentPlayer = game.currentPlayer;
                lastMove = game.lastMove;
                gameOver = game.gameOver;

                updatePlayerInfoUI(game);

                if (game.lastMove && game.lastMoveBy !== myColor) {
                    // Opponent made a move - play sound
                    if (game.lastMoveWasCapture) {
                        playSound('capture');
                    } else {
                        playSound('move');
                    }
                    if (game.inCheck && currentPlayer === myColor) {
                        playSound('check');
                    }
                }

                // Update status and stats
                if (gameOver) {
                    document.getElementById('rematchBtn').style.display = 'inline-block';

                    // Update stats only once
                    if (!game.statsUpdated) {
                        if (game.winner === myColor) {
                            statusEl.textContent = '‰Ω†Ëµ¢‰∫Ü!';
                            playSound('victory');
                            await updateUserStats('win');
                        } else if (game.winner) {
                            statusEl.textContent = '‰Ω†Ëæì‰∫Ü!';
                            playSound('defeat');
                            await updateUserStats('loss');
                        } else {
                            statusEl.textContent = 'ÂíåÊ£ã!';
                            await updateUserStats('draw');
                        }

                        // Mark stats as updated (only one player should do this)
                        if (myColor === 'red') {
                            gameRef.update({ statsUpdated: true });
                        }
                    } else {
                        if (game.winner === myColor) {
                            statusEl.textContent = '‰Ω†Ëµ¢‰∫Ü!';
                        } else if (game.winner) {
                            statusEl.textContent = '‰Ω†Ëæì‰∫Ü!';
                        } else {
                            statusEl.textContent = 'ÂíåÊ£ã!';
                        }
                    }
                } else if (currentPlayer === myColor) {
                    statusEl.textContent = 'ËΩÆÂà∞‰Ω†Ëµ∞Ê£ã';
                } else {
                    statusEl.textContent = 'Á≠âÂæÖÂØπÊâã...';
                }

                // Handle rematch request
                if (game.rematchRequest && game.rematchRequest !== myColor) {
                    if (confirm('ÂØπÊâãËØ∑Ê±ÇÂÜçÊù•‰∏ÄÂ±ÄÔºåÊòØÂê¶ÂêåÊÑèÔºü')) {
                        gameRef.update({
                            board: getInitialBoard(),
                            currentPlayer: 'red',
                            lastMove: null,
                            gameOver: false,
                            winner: null,
                            rematchRequest: null,
                            inCheck: false,
                            statsUpdated: false
                        });
                        document.getElementById('rematchBtn').style.display = 'none';
                    }
                }

                drawBoard();
            });

            // Handle disconnection
            const playerPath = myColor === 'red' ? 'redPlayer' : 'blackPlayer';
            gameRef.child(playerPath).onDisconnect().set(null);
        }

        function leaveGame() {
            if (!isAIGame && gameRef) {
                gameRef.off();
                if (myColor === 'red') {
                    gameRef.remove();
                } else {
                    gameRef.update({ blackPlayer: null });
                }
            }
            gameStarted = false;
            gameOver = false;
            isAIGame = false;
            aiThinking = false;
            selectedPiece = null;
            validMoves = [];
            lastMove = null;
            document.getElementById('rematchBtn').style.display = 'none';
            document.getElementById('gameArea').style.display = 'none';
            document.getElementById('lobby').style.display = 'block';

            // Show appropriate section based on selected mode
            selectMode(selectedGameMode);
            document.getElementById('waitingSection').style.display = 'none';

            // Clear URL params
            window.history.replaceState({}, document.title, window.location.pathname);
        }

        function requestRematch() {
            if (isAIGame) {
                // AI game - just restart
                gameOver = false;
                currentPlayer = 'red';
                selectedPiece = null;
                validMoves = [];
                lastMove = null;
                initBoard();
                document.getElementById('rematchBtn').style.display = 'none';
                updateAIGameUI();
                drawBoard();
            } else {
                gameRef.update({ rematchRequest: myColor });
                alert('Â∑≤ÂèëÈÄÅÂÜçÊù•‰∏ÄÂ±ÄËØ∑Ê±ÇÔºåÁ≠âÂæÖÂØπÊâãÁ°ÆËÆ§...');
            }
        }

        function copyLink() {
            const link = document.getElementById('shareLink').href;
            navigator.clipboard.writeText(link).then(() => {
                alert('ÈìæÊé•Â∑≤Â§çÂà∂!');
            });
        }

        // ============================================
        // GAME RENDERING & LOGIC
        // ============================================

        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');

        // Sound system
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let soundEnabled = true;

        function playSound(type) {
            if (!soundEnabled) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            switch (type) {
                case 'select':
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.1);
                    break;
                case 'move':
                    oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.1);
                    oscillator.type = 'triangle';
                    gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.15);
                    break;
                case 'capture':
                    oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.2);
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.25);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.25);
                    break;
                case 'check':
                    oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime + 0.1);
                    oscillator.frequency.setValueAtTime(600, audioCtx.currentTime + 0.2);
                    oscillator.type = 'square';
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.35);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.35);
                    break;
                case 'victory':
                    [523, 659, 784, 1047].forEach((freq, i) => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        osc.frequency.setValueAtTime(freq, audioCtx.currentTime + i * 0.15);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0.3, audioCtx.currentTime + i * 0.15);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.15 + 0.3);
                        osc.start(audioCtx.currentTime + i * 0.15);
                        osc.stop(audioCtx.currentTime + i * 0.15 + 0.3);
                    });
                    return;
                case 'defeat':
                    oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.5);
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.6);
                    break;
            }
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundBtn').textContent = soundEnabled ? 'ÂÖ≥Èó≠Èü≥Êïà' : 'ÂºÄÂêØÈü≥Êïà';
        }

        // Base dimensions (for scaling)
        const BASE_WIDTH = 520;
        const BASE_HEIGHT = 580;
        const BASE_CELL_SIZE = 57;
        const BASE_MARGIN = 30;
        const COLS = 9;
        const ROWS = 10;

        // Dynamic scaling variables
        let scale = 1;
        let CELL_SIZE = BASE_CELL_SIZE;
        let MARGIN = BASE_MARGIN;

        function resizeCanvas() {
            const maxWidth = Math.min(window.innerWidth - 30, 520);
            scale = maxWidth / BASE_WIDTH;

            canvas.style.width = (BASE_WIDTH * scale) + 'px';
            canvas.style.height = (BASE_HEIGHT * scale) + 'px';

            canvas.width = BASE_WIDTH;
            canvas.height = BASE_HEIGHT;

            CELL_SIZE = BASE_CELL_SIZE;
            MARGIN = BASE_MARGIN;

            if (gameStarted) {
                drawBoard();
            }
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        const EMPTY = 0;
        const R_GENERAL = 1, R_ADVISOR = 2, R_ELEPHANT = 3, R_HORSE = 4, R_CHARIOT = 5, R_CANNON = 6, R_SOLDIER = 7;
        const B_GENERAL = 11, B_ADVISOR = 12, B_ELEPHANT = 13, B_HORSE = 14, B_CHARIOT = 15, B_CANNON = 16, B_SOLDIER = 17;

        const pieceNames = {
            [R_GENERAL]: 'Â∏Ö', [R_ADVISOR]: '‰ªï', [R_ELEPHANT]: 'Áõ∏', [R_HORSE]: 'È¶¨',
            [R_CHARIOT]: 'Ëªä', [R_CANNON]: 'ÁÇÆ', [R_SOLDIER]: 'ÂÖµ',
            [B_GENERAL]: 'Â∞Ü', [B_ADVISOR]: 'Â£´', [B_ELEPHANT]: 'Ë±°', [B_HORSE]: 'È©¨',
            [B_CHARIOT]: 'ËΩ¶', [B_CANNON]: 'Á†≤', [B_SOLDIER]: 'Âçí'
        };

        let board = [];
        let selectedPiece = null;
        let validMoves = [];
        let currentPlayer = 'red';
        let gameOver = false;
        let lastMove = null;

        function isRed(piece) { return piece >= 1 && piece <= 7; }
        function isBlack(piece) { return piece >= 11 && piece <= 17; }
        function isEnemy(piece1, piece2) {
            return (isRed(piece1) && isBlack(piece2)) || (isBlack(piece1) && isRed(piece2));
        }
        function isMyPiece(piece) {
            return myColor === 'red' ? isRed(piece) : isBlack(piece);
        }

        function getInitialBoard() {
            const b = Array(ROWS).fill(null).map(() => Array(COLS).fill(EMPTY));
            b[0][0] = B_CHARIOT; b[0][8] = B_CHARIOT;
            b[0][1] = B_HORSE; b[0][7] = B_HORSE;
            b[0][2] = B_ELEPHANT; b[0][6] = B_ELEPHANT;
            b[0][3] = B_ADVISOR; b[0][5] = B_ADVISOR;
            b[0][4] = B_GENERAL;
            b[2][1] = B_CANNON; b[2][7] = B_CANNON;
            b[3][0] = B_SOLDIER; b[3][2] = B_SOLDIER; b[3][4] = B_SOLDIER;
            b[3][6] = B_SOLDIER; b[3][8] = B_SOLDIER;
            b[9][0] = R_CHARIOT; b[9][8] = R_CHARIOT;
            b[9][1] = R_HORSE; b[9][7] = R_HORSE;
            b[9][2] = R_ELEPHANT; b[9][6] = R_ELEPHANT;
            b[9][3] = R_ADVISOR; b[9][5] = R_ADVISOR;
            b[9][4] = R_GENERAL;
            b[7][1] = R_CANNON; b[7][7] = R_CANNON;
            b[6][0] = R_SOLDIER; b[6][2] = R_SOLDIER; b[6][4] = R_SOLDIER;
            b[6][6] = R_SOLDIER; b[6][8] = R_SOLDIER;
            return b;
        }

        function initBoard() {
            board = getInitialBoard();
        }

        function drawBoard() {
            ctx.fillStyle = '#e8c373';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#5d4037';
            ctx.lineWidth = 1;

            for (let i = 0; i < ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(MARGIN, MARGIN + i * CELL_SIZE);
                ctx.lineTo(MARGIN + 8 * CELL_SIZE, MARGIN + i * CELL_SIZE);
                ctx.stroke();
            }

            for (let j = 0; j < COLS; j++) {
                ctx.beginPath();
                ctx.moveTo(MARGIN + j * CELL_SIZE, MARGIN);
                ctx.lineTo(MARGIN + j * CELL_SIZE, MARGIN + 4 * CELL_SIZE);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(MARGIN + j * CELL_SIZE, MARGIN + 5 * CELL_SIZE);
                ctx.lineTo(MARGIN + j * CELL_SIZE, MARGIN + 9 * CELL_SIZE);
                ctx.stroke();
            }

            ctx.beginPath();
            ctx.moveTo(MARGIN, MARGIN + 4 * CELL_SIZE);
            ctx.lineTo(MARGIN, MARGIN + 5 * CELL_SIZE);
            ctx.moveTo(MARGIN + 8 * CELL_SIZE, MARGIN + 4 * CELL_SIZE);
            ctx.lineTo(MARGIN + 8 * CELL_SIZE, MARGIN + 5 * CELL_SIZE);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(MARGIN + 3 * CELL_SIZE, MARGIN);
            ctx.lineTo(MARGIN + 5 * CELL_SIZE, MARGIN + 2 * CELL_SIZE);
            ctx.moveTo(MARGIN + 5 * CELL_SIZE, MARGIN);
            ctx.lineTo(MARGIN + 3 * CELL_SIZE, MARGIN + 2 * CELL_SIZE);
            ctx.moveTo(MARGIN + 3 * CELL_SIZE, MARGIN + 7 * CELL_SIZE);
            ctx.lineTo(MARGIN + 5 * CELL_SIZE, MARGIN + 9 * CELL_SIZE);
            ctx.moveTo(MARGIN + 5 * CELL_SIZE, MARGIN + 7 * CELL_SIZE);
            ctx.lineTo(MARGIN + 3 * CELL_SIZE, MARGIN + 9 * CELL_SIZE);
            ctx.stroke();

            ctx.font = '24px serif';
            ctx.fillStyle = '#5d4037';
            ctx.textAlign = 'center';
            ctx.fillText('Ê•ö Ê≤≥', MARGIN + 1.5 * CELL_SIZE, MARGIN + 4.6 * CELL_SIZE);
            ctx.fillText('Ê±â Áïå', MARGIN + 6.5 * CELL_SIZE, MARGIN + 4.6 * CELL_SIZE);

            if (lastMove) {
                const fromX = MARGIN + lastMove.fromCol * CELL_SIZE;
                const fromY = MARGIN + lastMove.fromRow * CELL_SIZE;
                ctx.fillStyle = 'rgba(255, 215, 0, 0.4)';
                ctx.fillRect(fromX - 28, fromY - 28, 56, 56);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.strokeRect(fromX - 28, fromY - 28, 56, 56);

                const toX = MARGIN + lastMove.toCol * CELL_SIZE;
                const toY = MARGIN + lastMove.toRow * CELL_SIZE;
                ctx.fillStyle = 'rgba(255, 140, 0, 0.4)';
                ctx.fillRect(toX - 28, toY - 28, 56, 56);
                ctx.strokeStyle = '#ff8c00';
                ctx.lineWidth = 2;
                ctx.strokeRect(toX - 28, toY - 28, 56, 56);
            }

            validMoves.forEach(move => {
                const x = MARGIN + move.col * CELL_SIZE;
                const y = MARGIN + move.row * CELL_SIZE;
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.fillStyle = board[move.row][move.col] !== EMPTY ? 'rgba(255,0,0,0.5)' : 'rgba(0,128,0,0.5)';
                ctx.fill();
            });

            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const piece = board[row][col];
                    if (piece !== EMPTY) {
                        drawPiece(col, row, piece, selectedPiece && selectedPiece.row === row && selectedPiece.col === col);
                    }
                }
            }
        }

        function drawPiece(col, row, piece, selected) {
            const x = MARGIN + col * CELL_SIZE;
            const y = MARGIN + row * CELL_SIZE;
            const radius = 25;

            ctx.beginPath();
            ctx.arc(x + 2, y + 2, radius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fill();

            const gradient = ctx.createRadialGradient(x - 5, y - 5, 0, x, y, radius);
            gradient.addColorStop(0, '#fff8dc');
            gradient.addColorStop(1, '#deb887');
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            ctx.strokeStyle = selected ? '#00ff00' : '#8b4513';
            ctx.lineWidth = selected ? 3 : 2;
            ctx.stroke();

            ctx.font = 'bold 28px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = isRed(piece) ? '#c41e3a' : '#1a1a1a';
            ctx.fillText(pieceNames[piece], x, y + 2);
        }

        function getValidMoves(row, col, boardState = board) {
            const piece = boardState[row][col];
            const moves = [];

            const addMove = (r, c) => {
                if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                    const target = boardState[r][c];
                    if (target === EMPTY || isEnemy(piece, target)) {
                        moves.push({ row: r, col: c });
                    }
                }
            };

            const canMoveTo = (r, c) => {
                if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return false;
                const target = boardState[r][c];
                return target === EMPTY || isEnemy(piece, target);
            };

            const pieceType = piece <= 7 ? piece : piece - 10;
            const isRedPiece = isRed(piece);

            switch (pieceType) {
                case 1:
                    const gMinRow = isRedPiece ? 7 : 0;
                    const gMaxRow = isRedPiece ? 9 : 2;
                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                        const nr = row + dr, nc = col + dc;
                        if (nr >= gMinRow && nr <= gMaxRow && nc >= 3 && nc <= 5 && canMoveTo(nr, nc)) {
                            moves.push({ row: nr, col: nc });
                        }
                    });
                    const enemyGeneral = isRedPiece ? B_GENERAL : R_GENERAL;
                    let blocked = false;
                    const dir = isRedPiece ? -1 : 1;
                    for (let r = row + dir; r >= 0 && r < ROWS; r += dir) {
                        if (boardState[r][col] === enemyGeneral && !blocked) {
                            moves.push({ row: r, col: col });
                            break;
                        }
                        if (boardState[r][col] !== EMPTY) blocked = true;
                    }
                    break;
                case 2:
                    const aMinRow = isRedPiece ? 7 : 0;
                    const aMaxRow = isRedPiece ? 9 : 2;
                    [[1, 1], [1, -1], [-1, 1], [-1, -1]].forEach(([dr, dc]) => {
                        const nr = row + dr, nc = col + dc;
                        if (nr >= aMinRow && nr <= aMaxRow && nc >= 3 && nc <= 5 && canMoveTo(nr, nc)) {
                            moves.push({ row: nr, col: nc });
                        }
                    });
                    break;
                case 3:
                    const eMinRow = isRedPiece ? 5 : 0;
                    const eMaxRow = isRedPiece ? 9 : 4;
                    [[2, 2, 1, 1], [2, -2, 1, -1], [-2, 2, -1, 1], [-2, -2, -1, -1]].forEach(([dr, dc, br, bc]) => {
                        const nr = row + dr, nc = col + dc;
                        const blockR = row + br, blockC = col + bc;
                        if (nr >= eMinRow && nr <= eMaxRow && nc >= 0 && nc < COLS &&
                            boardState[blockR][blockC] === EMPTY && canMoveTo(nr, nc)) {
                            moves.push({ row: nr, col: nc });
                        }
                    });
                    break;
                case 4:
                    [[2, 1, 1, 0], [2, -1, 1, 0], [-2, 1, -1, 0], [-2, -1, -1, 0],
                     [1, 2, 0, 1], [1, -2, 0, -1], [-1, 2, 0, 1], [-1, -2, 0, -1]
                    ].forEach(([dr, dc, br, bc]) => {
                        const nr = row + dr, nc = col + dc;
                        const blockR = row + br, blockC = col + bc;
                        if (blockR >= 0 && blockR < ROWS && blockC >= 0 && blockC < COLS &&
                            boardState[blockR][blockC] === EMPTY && canMoveTo(nr, nc)) {
                            moves.push({ row: nr, col: nc });
                        }
                    });
                    break;
                case 5:
                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                        for (let i = 1; i < 10; i++) {
                            const nr = row + dr * i, nc = col + dc * i;
                            if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) break;
                            if (boardState[nr][nc] === EMPTY) {
                                moves.push({ row: nr, col: nc });
                            } else {
                                if (isEnemy(piece, boardState[nr][nc])) moves.push({ row: nr, col: nc });
                                break;
                            }
                        }
                    });
                    break;
                case 6:
                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                        let jumped = false;
                        for (let i = 1; i < 10; i++) {
                            const nr = row + dr * i, nc = col + dc * i;
                            if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) break;
                            if (!jumped) {
                                if (boardState[nr][nc] === EMPTY) moves.push({ row: nr, col: nc });
                                else jumped = true;
                            } else {
                                if (boardState[nr][nc] !== EMPTY) {
                                    if (isEnemy(piece, boardState[nr][nc])) moves.push({ row: nr, col: nc });
                                    break;
                                }
                            }
                        }
                    });
                    break;
                case 7:
                    const forward = isRedPiece ? -1 : 1;
                    const crossedRiver = isRedPiece ? row <= 4 : row >= 5;
                    addMove(row + forward, col);
                    if (crossedRiver) {
                        addMove(row, col - 1);
                        addMove(row, col + 1);
                    }
                    break;
            }
            return moves;
        }

        function isInCheck(isRedPlayer, boardState = board) {
            let kingRow = -1, kingCol = -1;
            const kingPiece = isRedPlayer ? R_GENERAL : B_GENERAL;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (boardState[r][c] === kingPiece) {
                        kingRow = r; kingCol = c;
                        break;
                    }
                }
            }

            if (kingRow === -1) return true;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = boardState[r][c];
                    if (piece !== EMPTY && (isRedPlayer ? isBlack(piece) : isRed(piece))) {
                        const moves = getValidMoves(r, c, boardState);
                        if (moves.some(m => m.row === kingRow && m.col === kingCol)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function makeMoveOnBoard(fromRow, fromCol, toRow, toCol, boardState) {
            const captured = boardState[toRow][toCol];
            boardState[toRow][toCol] = boardState[fromRow][fromCol];
            boardState[fromRow][fromCol] = EMPTY;
            return captured;
        }

        function getLegalMoves(row, col, boardState = board) {
            const piece = boardState[row][col];
            const isRedPiece = isRed(piece);
            const moves = getValidMoves(row, col, boardState);

            return moves.filter(move => {
                const testBoard = boardState.map(r => [...r]);
                makeMoveOnBoard(row, col, move.row, move.col, testBoard);
                return !isInCheck(isRedPiece, testBoard);
            });
        }

        function hasLegalMoves(isRedPlayer, boardState = board) {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = boardState[r][c];
                    if (piece !== EMPTY && (isRedPlayer ? isRed(piece) : isBlack(piece))) {
                        if (getLegalMoves(r, c, boardState).length > 0) return true;
                    }
                }
            }
            return false;
        }

        function handleInteraction(clientX, clientY) {
            if (gameOver || currentPlayer !== myColor || !gameStarted || aiThinking) return;

            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;

            const col = Math.round((x - MARGIN) / CELL_SIZE);
            const row = Math.round((y - MARGIN) / CELL_SIZE);

            if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return;

            const clickedPiece = board[row][col];

            const moveIndex = validMoves.findIndex(m => m.row === row && m.col === col);
            if (moveIndex !== -1 && selectedPiece) {
                const captured = board[row][col];

                if (isAIGame) {
                    // AI game - update local state
                    makeMoveOnBoard(selectedPiece.row, selectedPiece.col, row, col, board);

                    lastMove = {
                        fromRow: selectedPiece.row,
                        fromCol: selectedPiece.col,
                        toRow: row,
                        toCol: col
                    };

                    if (captured !== EMPTY) {
                        playSound('capture');
                    } else {
                        playSound('move');
                    }

                    if (captured === B_GENERAL || !hasLegalMoves(false, board)) {
                        gameOver = true;
                        statusEl.textContent = '‰Ω†Ëµ¢‰∫Ü!';
                        playSound('victory');
                        updateUserStats('win');
                        document.getElementById('rematchBtn').style.display = 'inline-block';
                    } else if (isInCheck(false, board)) {
                        playSound('check');
                        currentPlayer = 'black';
                        setTimeout(makeAIMove, 300);
                    } else {
                        currentPlayer = 'black';
                        setTimeout(makeAIMove, 300);
                    }

                    selectedPiece = null;
                    validMoves = [];
                    updateAIGameUI();
                    drawBoard();
                    return;
                }

                // Online game - update Firebase
                const newBoard = board.map(r => [...r]);
                makeMoveOnBoard(selectedPiece.row, selectedPiece.col, row, col, newBoard);

                const newLastMove = {
                    fromRow: selectedPiece.row,
                    fromCol: selectedPiece.col,
                    toRow: row,
                    toCol: col
                };

                const nextPlayer = myColor === 'red' ? 'black' : 'red';
                const opponentIsRed = nextPlayer === 'red';
                const inCheck = isInCheck(opponentIsRed, newBoard);
                const opponentHasMoves = hasLegalMoves(opponentIsRed, newBoard);

                let isGameOver = false;
                let winner = null;

                if (captured === B_GENERAL || captured === R_GENERAL || !opponentHasMoves) {
                    isGameOver = true;
                    winner = myColor;
                }

                if (captured !== EMPTY) {
                    playSound('capture');
                } else {
                    playSound('move');
                }
                if (inCheck && !isGameOver) {
                    playSound('check');
                }
                if (isGameOver) {
                    playSound('victory');
                }

                gameRef.update({
                    board: newBoard,
                    currentPlayer: nextPlayer,
                    lastMove: newLastMove,
                    lastMoveBy: myColor,
                    lastMoveWasCapture: captured !== EMPTY,
                    inCheck: inCheck,
                    gameOver: isGameOver,
                    winner: winner
                });

                selectedPiece = null;
                validMoves = [];
                return;
            }

            if (isMyPiece(clickedPiece)) {
                selectedPiece = { row, col };
                validMoves = getLegalMoves(row, col);
                playSound('select');
                drawBoard();
            } else {
                selectedPiece = null;
                validMoves = [];
                drawBoard();
            }
        }

        canvas.addEventListener('click', (e) => {
            handleInteraction(e.clientX, e.clientY);
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleInteraction(touch.clientX, touch.clientY);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>
