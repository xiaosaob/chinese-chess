<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>中国象棋 - Chinese Chess</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            font-family: 'Microsoft YaHei', 'SimHei', sans-serif;
        }
        .game-container {
            text-align: center;
            padding: 20px;
        }
        h1 {
            color: #f4d03f;
            margin-bottom: 15px;
            font-size: 32px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .status {
            color: #fff;
            font-size: 20px;
            margin-bottom: 15px;
            min-height: 30px;
        }
        .board-container {
            display: inline-block;
            padding: 20px;
            background: #d4a056;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        canvas {
            cursor: pointer;
        }
        .controls {
            margin-top: 20px;
        }
        button {
            padding: 12px 30px;
            font-size: 18px;
            background: #c0392b;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 0 10px;
            font-family: inherit;
            transition: background 0.3s;
        }
        button:hover {
            background: #e74c3c;
        }
        .difficulty {
            margin-top: 15px;
            color: #fff;
        }
        .difficulty select {
            padding: 8px 15px;
            font-size: 16px;
            border-radius: 5px;
            border: none;
            margin-left: 10px;
        }
        .thinking {
            color: #f4d03f;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>中国象棋</h1>
        <div class="status" id="status">红方先行 - 请选择棋子</div>
        <div class="board-container">
            <canvas id="board" width="520" height="580"></canvas>
        </div>
        <div class="controls">
            <button onclick="newGame()">新游戏</button>
            <button onclick="undoMove()">悔棋</button>
            <button id="soundBtn" onclick="toggleSound()">关闭音效</button>
        </div>
        <div class="difficulty">
            难度:
            <select id="difficulty" onchange="changeDifficulty()">
                <option value="2">简单</option>
                <option value="3" selected>中等</option>
                <option value="4">困难</option>
            </select>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');

        // Sound system using Web Audio API
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let soundEnabled = true;

        function playSound(type) {
            if (!soundEnabled) return;

            // Resume audio context if suspended (browser autoplay policy)
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            switch (type) {
                case 'select':
                    // Short click sound
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialDecayTo = 0.01;
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.1);
                    break;

                case 'move':
                    // Wooden piece placement sound
                    oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.1);
                    oscillator.type = 'triangle';
                    gainNode.gain.setValueAtTime(0.4, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.15);
                    break;

                case 'capture':
                    // Impact sound for capture
                    oscillator.frequency.setValueAtTime(200, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.2);
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.25);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.25);
                    break;

                case 'check':
                    // Alert sound for check
                    oscillator.frequency.setValueAtTime(600, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime + 0.1);
                    oscillator.frequency.setValueAtTime(600, audioCtx.currentTime + 0.2);
                    oscillator.type = 'square';
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime + 0.25);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.35);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.35);
                    break;

                case 'victory':
                    // Fanfare for victory
                    const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
                    notes.forEach((freq, i) => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        osc.frequency.setValueAtTime(freq, audioCtx.currentTime + i * 0.15);
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0.3, audioCtx.currentTime + i * 0.15);
                        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + i * 0.15 + 0.3);
                        osc.start(audioCtx.currentTime + i * 0.15);
                        osc.stop(audioCtx.currentTime + i * 0.15 + 0.3);
                    });
                    return; // Do not start the main oscillator

                case 'defeat':
                    // Sad sound for defeat
                    oscillator.frequency.setValueAtTime(400, audioCtx.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + 0.5);
                    oscillator.type = 'sine';
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.6);
                    break;
            }
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundBtn').textContent = soundEnabled ? '关闭音效' : '开启音效';
        }

        const CELL_SIZE = 57;
        const MARGIN = 30;
        const COLS = 9;
        const ROWS = 10;

        // Piece types
        const EMPTY = 0;
        const R_GENERAL = 1, R_ADVISOR = 2, R_ELEPHANT = 3, R_HORSE = 4, R_CHARIOT = 5, R_CANNON = 6, R_SOLDIER = 7;
        const B_GENERAL = 11, B_ADVISOR = 12, B_ELEPHANT = 13, B_HORSE = 14, B_CHARIOT = 15, B_CANNON = 16, B_SOLDIER = 17;

        const pieceNames = {
            [R_GENERAL]: '帅', [R_ADVISOR]: '仕', [R_ELEPHANT]: '相', [R_HORSE]: '馬',
            [R_CHARIOT]: '車', [R_CANNON]: '炮', [R_SOLDIER]: '兵',
            [B_GENERAL]: '将', [B_ADVISOR]: '士', [B_ELEPHANT]: '象', [B_HORSE]: '马',
            [B_CHARIOT]: '车', [B_CANNON]: '砲', [B_SOLDIER]: '卒'
        };

        // Piece values for AI
        const pieceValues = {
            [R_GENERAL]: 10000, [R_ADVISOR]: 20, [R_ELEPHANT]: 20, [R_HORSE]: 40,
            [R_CHARIOT]: 90, [R_CANNON]: 45, [R_SOLDIER]: 10,
            [B_GENERAL]: 10000, [B_ADVISOR]: 20, [B_ELEPHANT]: 20, [B_HORSE]: 40,
            [B_CHARIOT]: 90, [B_CANNON]: 45, [B_SOLDIER]: 10
        };

        let board = [];
        let selectedPiece = null;
        let validMoves = [];
        let currentPlayer = 'red';
        let gameOver = false;
        let aiDepth = 3;
        let moveHistory = [];
        let aiThinking = false;
        let lastMove = null; // Track last move for highlighting

        function isRed(piece) { return piece >= 1 && piece <= 7; }
        function isBlack(piece) { return piece >= 11 && piece <= 17; }
        function isEnemy(piece1, piece2) {
            return (isRed(piece1) && isBlack(piece2)) || (isBlack(piece1) && isRed(piece2));
        }

        function initBoard() {
            board = Array(ROWS).fill(null).map(() => Array(COLS).fill(EMPTY));

            // Black pieces (top)
            board[0][0] = B_CHARIOT; board[0][8] = B_CHARIOT;
            board[0][1] = B_HORSE; board[0][7] = B_HORSE;
            board[0][2] = B_ELEPHANT; board[0][6] = B_ELEPHANT;
            board[0][3] = B_ADVISOR; board[0][5] = B_ADVISOR;
            board[0][4] = B_GENERAL;
            board[2][1] = B_CANNON; board[2][7] = B_CANNON;
            board[3][0] = B_SOLDIER; board[3][2] = B_SOLDIER; board[3][4] = B_SOLDIER;
            board[3][6] = B_SOLDIER; board[3][8] = B_SOLDIER;

            // Red pieces (bottom)
            board[9][0] = R_CHARIOT; board[9][8] = R_CHARIOT;
            board[9][1] = R_HORSE; board[9][7] = R_HORSE;
            board[9][2] = R_ELEPHANT; board[9][6] = R_ELEPHANT;
            board[9][3] = R_ADVISOR; board[9][5] = R_ADVISOR;
            board[9][4] = R_GENERAL;
            board[7][1] = R_CANNON; board[7][7] = R_CANNON;
            board[6][0] = R_SOLDIER; board[6][2] = R_SOLDIER; board[6][4] = R_SOLDIER;
            board[6][6] = R_SOLDIER; board[6][8] = R_SOLDIER;
        }

        function drawBoard() {
            // Background
            ctx.fillStyle = '#e8c373';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#5d4037';
            ctx.lineWidth = 1;

            // Draw grid lines
            for (let i = 0; i < ROWS; i++) {
                ctx.beginPath();
                ctx.moveTo(MARGIN, MARGIN + i * CELL_SIZE);
                ctx.lineTo(MARGIN + 8 * CELL_SIZE, MARGIN + i * CELL_SIZE);
                ctx.stroke();
            }

            for (let j = 0; j < COLS; j++) {
                ctx.beginPath();
                ctx.moveTo(MARGIN + j * CELL_SIZE, MARGIN);
                ctx.lineTo(MARGIN + j * CELL_SIZE, MARGIN + 4 * CELL_SIZE);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(MARGIN + j * CELL_SIZE, MARGIN + 5 * CELL_SIZE);
                ctx.lineTo(MARGIN + j * CELL_SIZE, MARGIN + 9 * CELL_SIZE);
                ctx.stroke();
            }

            // Side borders
            ctx.beginPath();
            ctx.moveTo(MARGIN, MARGIN + 4 * CELL_SIZE);
            ctx.lineTo(MARGIN, MARGIN + 5 * CELL_SIZE);
            ctx.moveTo(MARGIN + 8 * CELL_SIZE, MARGIN + 4 * CELL_SIZE);
            ctx.lineTo(MARGIN + 8 * CELL_SIZE, MARGIN + 5 * CELL_SIZE);
            ctx.stroke();

            // Palace diagonals
            ctx.beginPath();
            ctx.moveTo(MARGIN + 3 * CELL_SIZE, MARGIN);
            ctx.lineTo(MARGIN + 5 * CELL_SIZE, MARGIN + 2 * CELL_SIZE);
            ctx.moveTo(MARGIN + 5 * CELL_SIZE, MARGIN);
            ctx.lineTo(MARGIN + 3 * CELL_SIZE, MARGIN + 2 * CELL_SIZE);
            ctx.moveTo(MARGIN + 3 * CELL_SIZE, MARGIN + 7 * CELL_SIZE);
            ctx.lineTo(MARGIN + 5 * CELL_SIZE, MARGIN + 9 * CELL_SIZE);
            ctx.moveTo(MARGIN + 5 * CELL_SIZE, MARGIN + 7 * CELL_SIZE);
            ctx.lineTo(MARGIN + 3 * CELL_SIZE, MARGIN + 9 * CELL_SIZE);
            ctx.stroke();

            // River text
            ctx.font = '24px serif';
            ctx.fillStyle = '#5d4037';
            ctx.textAlign = 'center';
            ctx.fillText('楚 河', MARGIN + 1.5 * CELL_SIZE, MARGIN + 4.6 * CELL_SIZE);
            ctx.fillText('汉 界', MARGIN + 6.5 * CELL_SIZE, MARGIN + 4.6 * CELL_SIZE);

            // Draw last move highlight
            if (lastMove) {
                // Highlight "from" position
                const fromX = MARGIN + lastMove.fromCol * CELL_SIZE;
                const fromY = MARGIN + lastMove.fromRow * CELL_SIZE;
                ctx.fillStyle = 'rgba(255, 215, 0, 0.4)';
                ctx.fillRect(fromX - 28, fromY - 28, 56, 56);
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.strokeRect(fromX - 28, fromY - 28, 56, 56);

                // Highlight "to" position
                const toX = MARGIN + lastMove.toCol * CELL_SIZE;
                const toY = MARGIN + lastMove.toRow * CELL_SIZE;
                ctx.fillStyle = 'rgba(255, 140, 0, 0.4)';
                ctx.fillRect(toX - 28, toY - 28, 56, 56);
                ctx.strokeStyle = '#ff8c00';
                ctx.lineWidth = 2;
                ctx.strokeRect(toX - 28, toY - 28, 56, 56);
            }

            // Draw valid move indicators
            validMoves.forEach(move => {
                const x = MARGIN + move.col * CELL_SIZE;
                const y = MARGIN + move.row * CELL_SIZE;
                ctx.beginPath();
                ctx.arc(x, y, 8, 0, Math.PI * 2);
                ctx.fillStyle = board[move.row][move.col] !== EMPTY ? 'rgba(255,0,0,0.5)' : 'rgba(0,128,0,0.5)';
                ctx.fill();
            });

            // Draw pieces
            for (let row = 0; row < ROWS; row++) {
                for (let col = 0; col < COLS; col++) {
                    const piece = board[row][col];
                    if (piece !== EMPTY) {
                        drawPiece(col, row, piece, selectedPiece && selectedPiece.row === row && selectedPiece.col === col);
                    }
                }
            }
        }

        function drawPiece(col, row, piece, selected) {
            const x = MARGIN + col * CELL_SIZE;
            const y = MARGIN + row * CELL_SIZE;
            const radius = 25;

            // Shadow
            ctx.beginPath();
            ctx.arc(x + 2, y + 2, radius, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fill();

            // Piece background
            const gradient = ctx.createRadialGradient(x - 5, y - 5, 0, x, y, radius);
            gradient.addColorStop(0, '#fff8dc');
            gradient.addColorStop(1, '#deb887');
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();

            // Border
            ctx.strokeStyle = selected ? '#00ff00' : '#8b4513';
            ctx.lineWidth = selected ? 3 : 2;
            ctx.stroke();

            // Text
            ctx.font = 'bold 28px serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = isRed(piece) ? '#c41e3a' : '#1a1a1a';
            ctx.fillText(pieceNames[piece], x, y + 2);
        }

        function getValidMoves(row, col, boardState = board) {
            const piece = boardState[row][col];
            const moves = [];

            const addMove = (r, c) => {
                if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                    const target = boardState[r][c];
                    if (target === EMPTY || isEnemy(piece, target)) {
                        moves.push({ row: r, col: c });
                    }
                }
            };

            const canMoveTo = (r, c) => {
                if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return false;
                const target = boardState[r][c];
                return target === EMPTY || isEnemy(piece, target);
            };

            const pieceType = piece <= 7 ? piece : piece - 10;
            const isRedPiece = isRed(piece);

            switch (pieceType) {
                case 1: // General
                    const gMinRow = isRedPiece ? 7 : 0;
                    const gMaxRow = isRedPiece ? 9 : 2;
                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                        const nr = row + dr, nc = col + dc;
                        if (nr >= gMinRow && nr <= gMaxRow && nc >= 3 && nc <= 5 && canMoveTo(nr, nc)) {
                            moves.push({ row: nr, col: nc });
                        }
                    });
                    // Flying general
                    const enemyGeneral = isRedPiece ? B_GENERAL : R_GENERAL;
                    let blocked = false;
                    const dir = isRedPiece ? -1 : 1;
                    for (let r = row + dir; r >= 0 && r < ROWS; r += dir) {
                        if (boardState[r][col] === enemyGeneral && !blocked) {
                            moves.push({ row: r, col: col });
                            break;
                        }
                        if (boardState[r][col] !== EMPTY) blocked = true;
                    }
                    break;

                case 2: // Advisor
                    const aMinRow = isRedPiece ? 7 : 0;
                    const aMaxRow = isRedPiece ? 9 : 2;
                    [[1, 1], [1, -1], [-1, 1], [-1, -1]].forEach(([dr, dc]) => {
                        const nr = row + dr, nc = col + dc;
                        if (nr >= aMinRow && nr <= aMaxRow && nc >= 3 && nc <= 5 && canMoveTo(nr, nc)) {
                            moves.push({ row: nr, col: nc });
                        }
                    });
                    break;

                case 3: // Elephant
                    const eMinRow = isRedPiece ? 5 : 0;
                    const eMaxRow = isRedPiece ? 9 : 4;
                    [[2, 2, 1, 1], [2, -2, 1, -1], [-2, 2, -1, 1], [-2, -2, -1, -1]].forEach(([dr, dc, br, bc]) => {
                        const nr = row + dr, nc = col + dc;
                        const blockR = row + br, blockC = col + bc;
                        if (nr >= eMinRow && nr <= eMaxRow && nc >= 0 && nc < COLS &&
                            boardState[blockR][blockC] === EMPTY && canMoveTo(nr, nc)) {
                            moves.push({ row: nr, col: nc });
                        }
                    });
                    break;

                case 4: // Horse
                    [
                        [2, 1, 1, 0], [2, -1, 1, 0], [-2, 1, -1, 0], [-2, -1, -1, 0],
                        [1, 2, 0, 1], [1, -2, 0, -1], [-1, 2, 0, 1], [-1, -2, 0, -1]
                    ].forEach(([dr, dc, br, bc]) => {
                        const nr = row + dr, nc = col + dc;
                        const blockR = row + br, blockC = col + bc;
                        if (blockR >= 0 && blockR < ROWS && blockC >= 0 && blockC < COLS &&
                            boardState[blockR][blockC] === EMPTY && canMoveTo(nr, nc)) {
                            moves.push({ row: nr, col: nc });
                        }
                    });
                    break;

                case 5: // Chariot
                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                        for (let i = 1; i < 10; i++) {
                            const nr = row + dr * i, nc = col + dc * i;
                            if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) break;
                            if (boardState[nr][nc] === EMPTY) {
                                moves.push({ row: nr, col: nc });
                            } else {
                                if (isEnemy(piece, boardState[nr][nc])) {
                                    moves.push({ row: nr, col: nc });
                                }
                                break;
                            }
                        }
                    });
                    break;

                case 6: // Cannon
                    [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
                        let jumped = false;
                        for (let i = 1; i < 10; i++) {
                            const nr = row + dr * i, nc = col + dc * i;
                            if (nr < 0 || nr >= ROWS || nc < 0 || nc >= COLS) break;
                            if (!jumped) {
                                if (boardState[nr][nc] === EMPTY) {
                                    moves.push({ row: nr, col: nc });
                                } else {
                                    jumped = true;
                                }
                            } else {
                                if (boardState[nr][nc] !== EMPTY) {
                                    if (isEnemy(piece, boardState[nr][nc])) {
                                        moves.push({ row: nr, col: nc });
                                    }
                                    break;
                                }
                            }
                        }
                    });
                    break;

                case 7: // Soldier
                    const forward = isRedPiece ? -1 : 1;
                    const crossedRiver = isRedPiece ? row <= 4 : row >= 5;
                    addMove(row + forward, col);
                    if (crossedRiver) {
                        addMove(row, col - 1);
                        addMove(row, col + 1);
                    }
                    break;
            }

            return moves;
        }

        function isInCheck(isRedPlayer, boardState = board) {
            let kingRow = -1, kingCol = -1;
            const kingPiece = isRedPlayer ? R_GENERAL : B_GENERAL;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (boardState[r][c] === kingPiece) {
                        kingRow = r; kingCol = c;
                        break;
                    }
                }
            }

            if (kingRow === -1) return true;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = boardState[r][c];
                    if (piece !== EMPTY && (isRedPlayer ? isBlack(piece) : isRed(piece))) {
                        const moves = getValidMoves(r, c, boardState);
                        if (moves.some(m => m.row === kingRow && m.col === kingCol)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function makeMove(fromRow, fromCol, toRow, toCol, boardState = board) {
            const captured = boardState[toRow][toCol];
            boardState[toRow][toCol] = boardState[fromRow][fromCol];
            boardState[fromRow][fromCol] = EMPTY;
            return captured;
        }

        function undoMoveOnBoard(fromRow, fromCol, toRow, toCol, captured, boardState = board) {
            boardState[fromRow][fromCol] = boardState[toRow][toCol];
            boardState[toRow][toCol] = captured;
        }

        function getLegalMoves(row, col, boardState = board) {
            const piece = boardState[row][col];
            const isRedPiece = isRed(piece);
            const moves = getValidMoves(row, col, boardState);

            return moves.filter(move => {
                const captured = makeMove(row, col, move.row, move.col, boardState);
                const inCheck = isInCheck(isRedPiece, boardState);
                undoMoveOnBoard(row, col, move.row, move.col, captured, boardState);
                return !inCheck;
            });
        }

        function evaluateBoard(boardState) {
            let score = 0;

            // Position bonus tables
            const positionBonus = {
                soldier: [
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0],
                    [1, 1, 3, 5, 5, 5, 3, 1, 1],
                    [2, 4, 6, 8, 10, 8, 6, 4, 2],
                    [3, 6, 9, 12, 15, 12, 9, 6, 3],
                    [4, 8, 12, 16, 20, 16, 12, 8, 4],
                    [5, 10, 15, 20, 25, 20, 15, 10, 5],
                    [6, 12, 18, 24, 30, 24, 18, 12, 6],
                    [0, 0, 0, 0, 0, 0, 0, 0, 0]
                ]
            };

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = boardState[r][c];
                    if (piece === EMPTY) continue;

                    let value = pieceValues[piece];

                    // Add position bonus for soldiers
                    if (piece === R_SOLDIER) {
                        value += positionBonus.soldier[r][c];
                    } else if (piece === B_SOLDIER) {
                        value += positionBonus.soldier[9 - r][c];
                    }

                    // Mobility bonus
                    const moves = getValidMoves(r, c, boardState);
                    value += moves.length * 0.5;

                    score += isRed(piece) ? -value : value;
                }
            }

            return score;
        }

        function getAllMoves(isRedPlayer, boardState) {
            const moves = [];
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const piece = boardState[r][c];
                    if (piece !== EMPTY && (isRedPlayer ? isRed(piece) : isBlack(piece))) {
                        const pieceMoves = getLegalMoves(r, c, boardState);
                        pieceMoves.forEach(m => {
                            moves.push({ fromRow: r, fromCol: c, toRow: m.row, toCol: m.col });
                        });
                    }
                }
            }
            return moves;
        }

        function minimax(boardState, depth, alpha, beta, isMaximizing) {
            if (depth === 0) {
                return { score: evaluateBoard(boardState) };
            }

            const moves = getAllMoves(!isMaximizing, boardState);

            if (moves.length === 0) {
                if (isInCheck(!isMaximizing, boardState)) {
                    return { score: isMaximizing ? -99999 : 99999 };
                }
                return { score: 0 };
            }

            let bestMove = null;

            if (isMaximizing) {
                let maxScore = -Infinity;
                for (const move of moves) {
                    const captured = makeMove(move.fromRow, move.fromCol, move.toRow, move.toCol, boardState);
                    const result = minimax(boardState, depth - 1, alpha, beta, false);
                    undoMoveOnBoard(move.fromRow, move.fromCol, move.toRow, move.toCol, captured, boardState);

                    if (result.score > maxScore) {
                        maxScore = result.score;
                        bestMove = move;
                    }
                    alpha = Math.max(alpha, result.score);
                    if (beta <= alpha) break;
                }
                return { score: maxScore, move: bestMove };
            } else {
                let minScore = Infinity;
                for (const move of moves) {
                    const captured = makeMove(move.fromRow, move.fromCol, move.toRow, move.toCol, boardState);
                    const result = minimax(boardState, depth - 1, alpha, beta, true);
                    undoMoveOnBoard(move.fromRow, move.fromCol, move.toRow, move.toCol, captured, boardState);

                    if (result.score < minScore) {
                        minScore = result.score;
                        bestMove = move;
                    }
                    beta = Math.min(beta, result.score);
                    if (beta <= alpha) break;
                }
                return { score: minScore, move: bestMove };
            }
        }

        function aiMove() {
            if (gameOver || currentPlayer !== 'black') return;

            aiThinking = true;
            statusEl.innerHTML = '<span class="thinking">AI思考中...</span>';
            drawBoard();

            setTimeout(() => {
                const boardCopy = board.map(row => [...row]);
                const result = minimax(boardCopy, aiDepth, -Infinity, Infinity, true);

                if (result.move) {
                    const captured = board[result.move.toRow][result.move.toCol];
                    moveHistory.push({
                        fromRow: result.move.fromRow,
                        fromCol: result.move.fromCol,
                        toRow: result.move.toRow,
                        toCol: result.move.toCol,
                        captured: captured,
                        player: 'black'
                    });

                    makeMove(result.move.fromRow, result.move.fromCol, result.move.toRow, result.move.toCol);

                    // Update last move for highlighting
                    lastMove = {
                        fromRow: result.move.fromRow,
                        fromCol: result.move.fromCol,
                        toRow: result.move.toRow,
                        toCol: result.move.toCol
                    };

                    // Play sound based on capture or move
                    if (captured !== EMPTY) {
                        playSound('capture');
                    } else {
                        playSound('move');
                    }

                    if (captured === R_GENERAL) {
                        gameOver = true;
                        statusEl.textContent = '黑方获胜！';
                        playSound('defeat');
                    } else if (isInCheck(true)) {
                        const redMoves = getAllMoves(true, board);
                        if (redMoves.length === 0) {
                            gameOver = true;
                            statusEl.textContent = '将死！黑方获胜！';
                            playSound('defeat');
                        } else {
                            currentPlayer = 'red';
                            statusEl.textContent = '将军！红方走棋';
                            playSound('check');
                        }
                    } else {
                        currentPlayer = 'red';
                        statusEl.textContent = '红方走棋';
                    }
                } else {
                    gameOver = true;
                    statusEl.textContent = '红方获胜！';
                    playSound('victory');
                }

                aiThinking = false;
                drawBoard();
            }, 100);
        }

        canvas.addEventListener('click', (e) => {
            if (gameOver || currentPlayer !== 'red' || aiThinking) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const col = Math.round((x - MARGIN) / CELL_SIZE);
            const row = Math.round((y - MARGIN) / CELL_SIZE);

            if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return;

            const clickedPiece = board[row][col];

            // Check if clicking on a valid move
            const moveIndex = validMoves.findIndex(m => m.row === row && m.col === col);
            if (moveIndex !== -1 && selectedPiece) {
                const captured = board[row][col];
                moveHistory.push({
                    fromRow: selectedPiece.row,
                    fromCol: selectedPiece.col,
                    toRow: row,
                    toCol: col,
                    captured: captured,
                    player: 'red'
                });

                makeMove(selectedPiece.row, selectedPiece.col, row, col);

                // Update last move for highlighting
                lastMove = {
                    fromRow: selectedPiece.row,
                    fromCol: selectedPiece.col,
                    toRow: row,
                    toCol: col
                };

                selectedPiece = null;
                validMoves = [];

                // Play sound based on capture or move
                if (captured !== EMPTY) {
                    playSound('capture');
                } else {
                    playSound('move');
                }

                if (captured === B_GENERAL) {
                    gameOver = true;
                    statusEl.textContent = '红方获胜！';
                    playSound('victory');
                    drawBoard();
                    return;
                }

                if (isInCheck(false)) {
                    const blackMoves = getAllMoves(false, board);
                    if (blackMoves.length === 0) {
                        gameOver = true;
                        statusEl.textContent = '将死！红方获胜！';
                        playSound('victory');
                        drawBoard();
                        return;
                    }
                    playSound('check');
                }

                currentPlayer = 'black';
                drawBoard();
                aiMove();
                return;
            }

            // Select a piece
            if (isRed(clickedPiece)) {
                selectedPiece = { row, col };
                validMoves = getLegalMoves(row, col);
                playSound('select');
                drawBoard();
            } else {
                selectedPiece = null;
                validMoves = [];
                drawBoard();
            }
        });

        function newGame() {
            initBoard();
            selectedPiece = null;
            validMoves = [];
            currentPlayer = 'red';
            gameOver = false;
            moveHistory = [];
            aiThinking = false;
            lastMove = null;
            statusEl.textContent = '红方先行 - 请选择棋子';
            drawBoard();
        }

        function undoMove() {
            if (moveHistory.length < 2 || aiThinking) return;

            // Undo AI move
            let prevMove = moveHistory.pop();
            undoMoveOnBoard(prevMove.fromRow, prevMove.fromCol, prevMove.toRow, prevMove.toCol, prevMove.captured);

            // Undo player move
            prevMove = moveHistory.pop();
            undoMoveOnBoard(prevMove.fromRow, prevMove.fromCol, prevMove.toRow, prevMove.toCol, prevMove.captured);

            // Update lastMove to show previous move if exists
            if (moveHistory.length > 0) {
                const prev = moveHistory[moveHistory.length - 1];
                lastMove = {
                    fromRow: prev.fromRow,
                    fromCol: prev.fromCol,
                    toRow: prev.toRow,
                    toCol: prev.toCol
                };
            } else {
                lastMove = null;
            }

            currentPlayer = 'red';
            gameOver = false;
            selectedPiece = null;
            validMoves = [];
            statusEl.textContent = '红方走棋';
            drawBoard();
        }

        function changeDifficulty() {
            aiDepth = parseInt(document.getElementById('difficulty').value);
        }

        // Initialize
        newGame();
    </script>
</body>
</html>
